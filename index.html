<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dzogchen Lineage Tree - Interactive Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        #search {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 200px;
        }

        .filter-btn {
            padding: 6px 12px;
            margin: 2px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .filter-btn:hover {
            background: #f0f0f0;
        }

        .filter-btn.active {
            background: #4CAF50;
            color: white;
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
        }

        .node-text {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }

        .node-date {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            fill: #666;
        }

        .link {
            fill: none;
            stroke-width: 2px;
            stroke-opacity: 0.7;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            font-size: 13px;
            line-height: 1.4;
        }

        .hidden {
            display: none;
        }

        .highlighted {
            stroke-width: 4px !important;
            stroke: #ff6b35 !important;
        }

        .transmission-label {
            font-size: 16px;
            font-weight: bold;
            fill: #444;
            text-anchor: middle;
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <input type="text" id="search" placeholder="Search for a teacher...">
            <div>
                <button class="filter-btn active" data-filter="all">All Lineages</button>
            </div>
        </div>

        <div id="legend">
            <h4 style="margin-top: 0;">Transmission Types</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #4FC3F7;"></div>
                <span>Mind-Mind (Primordial)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #BA68C8;"></div>
                <span>Symbolic Transmission</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #81C784;"></div>
                <span>Aural Lineage</span>
            </div>
        </div>

        <div class="tooltip hidden" id="tooltip"></div>
        <svg id="svg"></svg>
    </div>

    <script>
        // Load CSV data dynamically
        let graphData = null;
        let currentFilter = 'all';

        async function loadCSVData() {
            try {
                const response = await fetch('./data/dzogchen_lineage.csv');
                const csvText = await response.text();
                return csvText;
            } catch (error) {
                console.error('Error loading CSV:', error);
                return null;
            }
        }

        // Parse CSV data
        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = [];
                let inQuotes = false;
                let currentValue = '';
                
                for (let char of line) {
                    if (char === '"' && !inQuotes) {
                        inQuotes = true;
                    } else if (char === '"' && inQuotes) {
                        inQuotes = false;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue.trim());
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                values.push(currentValue.trim());

                const obj = {};
                headers.forEach((header, i) => {
                    obj[header.trim()] = values[i] || '';
                });
                return obj;
            });
        }

        // Identify main transmission spines algorithmically
        function identifyTransmissionSpines(nodes, links) {
            // Main spine entities - these form the core transmission lines
            const spineEntities = {
                vimalamitra: 'Vimalamitra',
                padmasambhava: 'Padmasambhava', 
                vairocana: 'Vairocana'
            };
            
            // Mark nodes with their primary lineage affiliation
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            return spineEntities;
        }
        
        // Mark all nodes with proper lineage affiliation for filtering
        function markAllNodesWithLineage(nodes, links) {
            // Define the main lineage ancestors
            const lineageAncestors = {
                'Vimalamitra': ['Vimalamitra', 'Jñānasūtra', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Padmasambhava': ['Padmasambhava', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Vairocana': ['Vairocana', 'Śrī Siṃha', 'Garab Dorje']
            };
            
            // Helper function to trace lineage ancestry
            function findLineageAncestry(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return null; // Prevent cycles
                visited.add(nodeId);
                
                // Check if this node is a lineage ancestor
                for (const [lineage, ancestors] of Object.entries(lineageAncestors)) {
                    if (ancestors.includes(nodeId)) {
                        return lineage;
                    }
                }
                
                // Check parents recursively
                const parentLinks = links.filter(link => link.target === nodeId);
                for (const link of parentLinks) {
                    const parentLineage = findLineageAncestry(link.source, new Set(visited));
                    if (parentLineage) return parentLineage;
                }
                
                return null;
            }
            
            // Assign lineage to all nodes
            nodes.forEach(node => {
                if (!node.primaryLineage) {
                    // First try to use existing lineage field
                    if (node.lineage && node.lineage !== 'All lineages') {
                        const lineageParts = node.lineage.split(';').map(l => l.trim());
                        for (const part of lineageParts) {
                            if (part.includes('Vimalamitra')) {
                                node.primaryLineage = 'Vimalamitra';
                                break;
                            } else if (part.includes('Padmasambhava')) {
                                node.primaryLineage = 'Padmasambhava';
                                break;
                            } else if (part.includes('Vairocana')) {
                                node.primaryLineage = 'Vairocana';
                                break;
                            }
                        }
                    }
                    
                    // If still no lineage, trace ancestry
                    if (!node.primaryLineage) {
                        node.primaryLineage = findLineageAncestry(node.id) || 'All lineages';
                    }
                }
            });
        }

        // Build node and link data
        function buildGraphData(data) {
            const nodes = new Map();
            const links = [];

            // Create nodes - now including Position_Date!
            data.forEach(person => {
                if (!nodes.has(person.Name_English)) {
                    nodes.set(person.Name_English, {
                        id: person.Name_English,
                        name: person.Name_English,
                        tibetan: person.Name_Wylie_Tibetan,
                        dates: person.Dates,
                        description: person.Description_English,
                        transmissionMode: person.Transmission_Mode,
                        lineage: person.Lineage,
                        positionDate: person.Position_Date, // Key addition!
                        level: 0,
                        children: []
                    });
                }
            });

            // Create links
            data.forEach(person => {
                if (person.Received_Teachings_From) {
                    const teachers = person.Received_Teachings_From.split(';').map(t => t.trim());
                    teachers.forEach(teacher => {
                        if (teacher && nodes.has(teacher) && nodes.has(person.Name_English)) {
                            links.push({
                                source: teacher,
                                target: person.Name_English,
                                lineage: person.Lineage
                            });
                            nodes.get(teacher).children.push(person.Name_English);
                        }
                    });
                }
            });

            // Convert to array and mark lineages
            const nodeArray = Array.from(nodes.values());
            
            // Ensure all nodes have proper lineage marking for filtering
            markAllNodesWithLineage(nodeArray, links);
            
            return {
                nodes: nodeArray,
                links: links
            };
        }

        // Get color based on transmission mode
        function getTransmissionColor(transmissionMode) {
            switch (transmissionMode) {
                case 'Mind to Mind':
                    return '#4FC3F7'; // Blue for Mind-to-Mind transmission
                case 'Symbolic':
                    return '#BA68C8'; // Purple for Symbolic transmission
                case 'Aural':
                    return '#81C784'; // Green for Aural transmission
                default:
                    return '#E0E0E0'; // Gray for unknown/mixed
            }
        }

        // Get arrowhead marker based on transmission mode
        function getArrowheadMarker(transmissionMode) {
            switch (transmissionMode) {
                case 'Mind to Mind':
                    return 'url(#arrowhead-mind)';
                case 'Symbolic':
                    return 'url(#arrowhead-symbolic)';
                case 'Aural':
                    return 'url(#arrowhead-aural)';
                default:
                    return 'url(#arrowhead-default)';
            }
        }

        // Parse Position_Date and map to fine-grained layer levels for better vertical resolution
        function parsePositionDate(positionDate) {
            if (!positionDate || positionDate === 'N/A' || positionDate === '') {
                return 20; // Put undated entities at layer 20
            }
            
            const rawDate = parseInt(positionDate);
            
            // Enhanced granular mapping - much finer time resolution (30+ layers)
            if (rawDate === 0) return 0;
            if (rawDate === 1) return 1;
            if (rawDate === 2) return 2;
            if (rawDate === 3) return 3;
            
            // Pre-historical period - finer granularity
            if (rawDate >= 500 && rawDate < 550) return 4; // Early Garab Dorje period
            if (rawDate >= 550 && rawDate < 600) return 5; // Late pre-historical
            if (rawDate >= 600 && rawDate < 650) return 6; // Śākyamuni Buddha period
            if (rawDate >= 650 && rawDate < 680) return 7; // Post-Buddha early period
            if (rawDate >= 680 && rawDate < 700) return 8; // Mañjuśrimitra period
            if (rawDate >= 700 && rawDate < 720) return 9; // Early Śrī Siṃha period
            if (rawDate >= 720 && rawDate < 750) return 10; // Late Śrī Siṃha period
            
            // Critical 8th century - very fine granularity due to many figures
            if (rawDate >= 750 && rawDate < 770) return 11; // Early Padmasambhava/Jñānasūtra
            if (rawDate >= 770 && rawDate < 790) return 12; // Mid 8th century
            if (rawDate >= 790 && rawDate < 810) return 13; // Late 8th century (Vimalamitra/Vairocana)
            if (rawDate >= 810 && rawDate < 830) return 14; // Early 9th century transition
            if (rawDate >= 830 && rawDate < 850) return 15; // Mid 9th century
            if (rawDate >= 850 && rawDate < 875) return 16; // Late 9th century
            if (rawDate >= 875 && rawDate < 900) return 17; // End 9th century
            
            // 10th-11th centuries - moderate granularity
            if (rawDate >= 900 && rawDate < 950) return 18; // Early 10th century
            if (rawDate >= 950 && rawDate < 1000) return 19; // Late 10th century
            if (rawDate >= 1000 && rawDate < 1050) return 20; // Early 11th century
            if (rawDate >= 1050 && rawDate < 1100) return 21; // Mid 11th century
            if (rawDate >= 1100 && rawDate < 1150) return 22; // Late 11th century
            if (rawDate >= 1150 && rawDate < 1200) return 23; // Early 12th century
            
            // Later periods - reasonable granularity
            if (rawDate >= 1200 && rawDate < 1250) return 24; // Early 13th century
            if (rawDate >= 1250 && rawDate < 1300) return 25; // Mid 13th century
            if (rawDate >= 1300 && rawDate < 1350) return 26; // Early 14th century
            if (rawDate >= 1350 && rawDate < 1400) return 27; // Mid 14th century
            if (rawDate >= 1400 && rawDate < 1450) return 28; // 15th century
            if (rawDate >= 1450) return 29; // Later periods
            
            return 20; // fallback
        }

        // Assign vertical positions using Position_Date from CSV
        function assignVerticalPositions(nodes, links) {
            // Use Position_Date directly for vertical positioning - this is the key change!
            nodes.forEach(node => {
                node.timeLayer = parsePositionDate(node.positionDate);
                // Convert timeLayer to level for compatibility with existing rendering code
                node.level = node.timeLayer;
            });

            return nodes;
        }

        // Split data into three separate lineage trees for preprocessing
        function splitIntoLineageTrees(nodes, links) {
            console.log('=== SPLITTING INTO LINEAGE TREES ===');
            
            const lineages = {
                vimalamitra: { nodes: [], links: [] },
                padmasambhava: { nodes: [], links: [] },
                vairocana: { nodes: [], links: [] },
                shared: { nodes: [], links: [] } // For nodes that belong to multiple lineages
            };
            
            // Identify shared ancestor nodes that appear in multiple lineages
            const sharedAncestors = ['Samantabhadra/Samantabhadrī', 'Buddhas of the Five Families', 
                                   'Supreme Emanation Blessing', 'Sublime Wisdom Emanation (Vajradhara)',
                                   'Vajrasattva', 'Vajrapāṇi', 'Cheu Nangwa Dampa Samkyi Mikhyapa', 
                                   'Śākyamuni Buddha', 'Garab Dorje', 'Mañjuśrimitra', 'Śrī Siṃha'];
            
            // Split nodes into lineages
            nodes.forEach(node => {
                if (sharedAncestors.includes(node.id)) {
                    lineages.shared.nodes.push(node);
                } else if (node.primaryLineage === 'Vimalamitra' || 
                          (node.lineage && node.lineage.includes('Vimalamitra'))) {
                    lineages.vimalamitra.nodes.push(node);
                } else if (node.primaryLineage === 'Padmasambhava' || 
                          (node.lineage && node.lineage.includes('Padmasambhava'))) {
                    lineages.padmasambhava.nodes.push(node);
                } else if (node.primaryLineage === 'Vairocana' || 
                          (node.lineage && node.lineage.includes('Vairocana'))) {
                    lineages.vairocana.nodes.push(node);
                } else {
                    lineages.shared.nodes.push(node); // Fallback to shared
                }
            });
            
            // Split links based on node assignments
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                
                if (!sourceNode || !targetNode) return;
                
                // Determine which lineage this link belongs to based on target node
                if (lineages.vimalamitra.nodes.includes(targetNode)) {
                    lineages.vimalamitra.links.push(link);
                } else if (lineages.padmasambhava.nodes.includes(targetNode)) {
                    lineages.padmasambhava.links.push(link);
                } else if (lineages.vairocana.nodes.includes(targetNode)) {
                    lineages.vairocana.links.push(link);
                } else {
                    lineages.shared.links.push(link);
                }
            });
            
            console.log('Lineage split results:', {
                vimalamitra: lineages.vimalamitra.nodes.length + ' nodes',
                padmasambhava: lineages.padmasambhava.nodes.length + ' nodes', 
                vairocana: lineages.vairocana.nodes.length + ' nodes',
                shared: lineages.shared.nodes.length + ' nodes'
            });
            
            return lineages;
        }

        // Build hierarchical tree structure for D3
        function buildLineageHierarchy(lineageData) {
            const { nodes, links } = lineageData;
            if (nodes.length === 0) return null;
            
            // Create maps for tree building
            const nodeMap = new Map(nodes.map(n => [n.id, { ...n, children: [] }]));
            const hasParent = new Set();
            
            // Build parent-child relationships
            links.forEach(link => {
                const parent = nodeMap.get(link.source);
                const child = nodeMap.get(link.target);
                if (parent && child) {
                    parent.children.push(child);
                    hasParent.add(link.target);
                }
            });
            
            // Find root nodes (nodes with no parents in this lineage)
            const roots = nodes.filter(n => !hasParent.has(n.id)).map(n => nodeMap.get(n.id));
            
            // If multiple roots, create artificial root to connect them
            if (roots.length === 1) {
                return roots[0];
            } else if (roots.length > 1) {
                return {
                    id: 'artificial-root',
                    name: 'Root',
                    children: roots
                };
            }
            return null;
        }

        // Use D3's native tree layout for proper positioning
        function positionLineageNodes(lineageData, baseX, lineageWidth = 400) {
            console.log('Using D3 tree layout for lineage with base X:', baseX);
            
            const { nodes } = lineageData;
            if (nodes.length === 0) return;
            
            // Build D3 hierarchy
            const root = buildLineageHierarchy(lineageData);
            if (!root) return;
            
            // Create D3 tree layout
            const treeLayout = d3.tree()
                .size([lineageWidth, 1000]) // Width x Height - height doesn't matter since we'll override Y
                .separation((a, b) => {
                    // Good separation between siblings
                    return a.parent === b.parent ? 1.5 : 2;
                });
            
            // Apply D3 tree layout
            const hierarchy = d3.hierarchy(root);
            const treeNodes = treeLayout(hierarchy);
            
            // Extract D3's X positions and store them
            treeNodes.each(d => {
                const originalNode = nodes.find(n => n.id === d.data.id);
                if (originalNode && d.data.id !== 'artificial-root') {
                    // D3's X becomes our relative X within the lineage
                    originalNode.lineageX = baseX + (d.x - lineageWidth/2); // Center the tree around baseX
                    console.log(`${originalNode.name}: D3 positioned at X=${d.x} -> lineageX=${originalNode.lineageX}`);
                }
            });
        }

        // New main positioning function using lineage preprocessing with D3 tree layout
        function applyLineageBasedLayout(nodes, links) {
            console.log('=== LINEAGE-BASED LAYOUT WITH D3 TREES ===');
            
            // Step 1: Split into lineage trees
            const lineages = splitIntoLineageTrees(nodes, links);
            
            // Step 2: Use D3 tree layout for each lineage's X positioning
            positionLineageNodes(lineages.vimalamitra, 300, 400);   // Left column, 400px wide
            positionLineageNodes(lineages.padmasambhava, 800, 400); // Center column, 400px wide
            positionLineageNodes(lineages.vairocana, 1300, 400);    // Right column, 400px wide
            
            // Step 3: Apply D3 tree layout to shared ancestors too (no more hardcoding!)
            positionLineageNodes(lineages.shared, 800, 600);        // Center column, wider to accommodate branching
            
            // Step 4: Apply final positioning - D3's X + Chronological Y with sub-layer offsets
            
            // First, group nodes by timeLayer to detect stacking
            const layerGroups = d3.groups(nodes, d => d.timeLayer);
            const layerOffsets = new Map();
            
            layerGroups.forEach(([timeLayer, layerNodes]) => {
                // All nodes in the same time layer get no vertical offset - they align horizontally
                layerNodes.forEach(node => {
                    layerOffsets.set(node.id, 0);
                    console.log(`Layer ${timeLayer}: ${node.name} gets Y offset 0 (no staggering)`);
                });
            });
            
            // Apply final positioning
            nodes.forEach(node => {
                // Use D3's calculated X position (lineageX) or fallback to center
                if (typeof node.lineageX === 'number') {
                    node.treeX = node.lineageX;
                } else {
                    node.treeX = 800; // Default center position
                }
                
                // Apply chronological Y + sub-layer offset
                const baseY = node.timeLayer * 140;
                const offset = layerOffsets.get(node.id) || 0;
                node.treeY = baseY + offset;
                
                console.log(`Final position - ${node.name}: (${node.treeX}, ${node.treeY}) [base: ${baseY}, offset: ${offset}]`);
            });
            
            console.log('=== D3 LINEAGE LAYOUT COMPLETE ===');
            return nodes;
        }
        
        // Step 3: Apply chronological constraints with intelligent sub-layering
        function applyChronologicalConstraints(nodes) {
            console.log('Applying chronological constraints with intelligent sub-layering...');
            
            // Group nodes by time layer to detect crowded periods
            const layerGroups = d3.groups(nodes, d => d.timeLayer);
            const layerAdjustments = new Map();
            
            // Detect crowded layers and plan sub-layer adjustments
            layerGroups.forEach(([timeLayer, layerNodes]) => {
                if (layerNodes.length > 3) { // If more than 3 nodes in same time layer
                    console.log(`Crowded layer ${timeLayer} detected with ${layerNodes.length} nodes`);
                    
                    // Sort nodes by their tree branching position for consistent sub-layering
                    layerNodes.sort((a, b) => (a.d3TreeX || 0) - (b.d3TreeX || 0));
                    
                    // Create sub-layers within the main time layer
                    const subLayerHeight = 0.8; // Fraction of main layer height for sub-layers
                    layerNodes.forEach((node, index) => {
                        const subLayerOffset = (index / (layerNodes.length - 1)) * subLayerHeight - (subLayerHeight / 2);
                        layerAdjustments.set(node.id, timeLayer + subLayerOffset);
                    });
                } else {
                    // Not crowded - use standard positioning
                    layerNodes.forEach(node => {
                        layerAdjustments.set(node.id, timeLayer);
                    });
                }
            });
            
            // Apply the calculated positions
            nodes.forEach(node => {
                // Use D3's X position for horizontal (preserves tree branching)
                node.treeX = node.d3TreeX || 0;
                
                // Use adjusted Y position with sub-layering
                const adjustedLayer = layerAdjustments.get(node.id) || node.timeLayer;
                const chronologicalY = adjustedLayer * 140; // Increased spacing for better visibility
                node.treeY = chronologicalY;
                
                console.log(`${node.name}: Layer ${node.timeLayer} -> Adjusted ${adjustedLayer.toFixed(2)} -> Y=${node.treeY}`);
            });
        }
        
        // Step 4: Adaptive spacing algorithm that expands crowded layers automatically
        function fixChronologicalOverlaps(nodes) {
            console.log('Applying adaptive spacing algorithm...');
            
            // Group nodes by their adjusted time layer (after sub-layering)
            const layerMap = new Map();
            nodes.forEach(node => {
                const adjustedLayer = Math.round(node.treeY / 140); // Convert back from pixels
                if (!layerMap.has(adjustedLayer)) {
                    layerMap.set(adjustedLayer, []);
                }
                layerMap.get(adjustedLayer).push(node);
            });
            
            // Process each layer
            layerMap.forEach((layerNodes, layerKey) => {
                if (layerNodes.length <= 1) return; // No overlaps possible
                
                // Sort by D3's original X position to maintain genealogical order
                layerNodes.sort((a, b) => (a.d3TreeX || 0) - (b.d3TreeX || 0));
                
                // Adaptive separation based on layer crowding
                let minSeparation = 180; // Base minimum separation
                
                if (layerNodes.length > 6) {
                    minSeparation = 220; // More space for very crowded layers
                } else if (layerNodes.length > 4) {
                    minSeparation = 200; // Extra space for moderately crowded
                }
                
                // Apply intelligent horizontal spacing
                for (let i = 1; i < layerNodes.length; i++) {
                    const prevNode = layerNodes[i - 1];
                    const currentNode = layerNodes[i];
                    
                    const currentSeparation = Math.abs(currentNode.treeX - prevNode.treeX);
                    
                    if (currentSeparation < minSeparation) {
                        // Too close! Apply adaptive expansion
                        const expansionNeeded = minSeparation - currentSeparation;
                        currentNode.treeX = prevNode.treeX + minSeparation;
                        
                        console.log(`Adaptive expansion: ${currentNode.name} moved from X=${currentNode.treeX - expansionNeeded} to X=${currentNode.treeX} (gap: ${minSeparation}px)`);
                        
                        // Ripple effect: push subsequent nodes if needed
                        for (let j = i + 1; j < layerNodes.length; j++) {
                            const nextNode = layerNodes[j];
                            if (Math.abs(nextNode.treeX - currentNode.treeX) < minSeparation) {
                                nextNode.treeX = currentNode.treeX + minSeparation;
                                console.log(`Ripple expansion: ${nextNode.name} adjusted to X=${nextNode.treeX}`);
                            } else {
                                break; // No more adjustments needed
                            }
                        }
                    }
                }
                
                console.log(`Layer ${layerKey} adaptive spacing complete: ${layerNodes.length} nodes with ${minSeparation}px separation`);
            });
        }
        
        // Build tree hierarchy from parent-child relationships
        function buildTreeHierarchy(nodes, links) {
            console.log('Building tree hierarchy...');
            
            // Create adjacency maps
            const childrenMap = new Map();
            const parentsMap = new Map();
            
            nodes.forEach(node => {
                childrenMap.set(node.id, []);
                parentsMap.set(node.id, []);
            });
            
            links.forEach(link => {
                if (childrenMap.has(link.source) && childrenMap.has(link.target)) {
                    childrenMap.get(link.source).push(link.target);
                    parentsMap.get(link.target).push(link.source);
                }
            });
            
            // Find root nodes (nodes with no parents)
            const rootNodes = nodes.filter(node => {
                const parents = parentsMap.get(node.id) || [];
                return parents.length === 0;
            });
            
            console.log(`Found ${rootNodes.length} root nodes:`, rootNodes.map(n => n.name));
            
            // Build tree structure recursively
            function buildChildren(parentNode) {
                const childIds = childrenMap.get(parentNode.id) || [];
                const children = childIds
                    .map(childId => nodes.find(n => n.id === childId))
                    .filter(child => child);
                    
                children.forEach(child => {
                    child.children = buildChildren(child);
                    child.parent = parentNode;
                });
                
                return children;
            }
            
            // Build full tree structure
            rootNodes.forEach(root => {
                root.children = buildChildren(root);
                root.parent = null;
                root.depth = 0;
            });
            
            return { roots: rootNodes, childrenMap, parentsMap };
        }


        // Initialize visualization
        const container = d3.select('#container');
        const svg = d3.select('#svg');
        const tooltip = d3.select('#tooltip');

        const width = window.innerWidth;
        const height = window.innerHeight;

        svg.attr('width', width).attr('height', height);

        const g = svg.append('g');

        // Define arrowhead markers for different transmission types
        const defs = svg.append('defs');
        
        // Mind-to-Mind transmission arrowhead (blue)
        defs.append('marker')
            .attr('id', 'arrowhead-mind')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#4FC3F7')
            .attr('opacity', 0.8);

        // Symbolic transmission arrowhead (purple)
        defs.append('marker')
            .attr('id', 'arrowhead-symbolic')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#BA68C8')
            .attr('opacity', 0.8);

        // Aural transmission arrowhead (green)
        defs.append('marker')
            .attr('id', 'arrowhead-aural')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#81C784')
            .attr('opacity', 0.8);

        // Default arrowhead (gray)
        defs.append('marker')
            .attr('id', 'arrowhead-default')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#666')
            .attr('opacity', 0.8);

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);

        // Initialize the application
        async function initializeApp() {
            const csvData = await loadCSVData();
            if (!csvData) {
                console.error('Failed to load CSV data');
                return;
            }

            // Parse data and build graph
            const rawData = parseCSV(csvData);
            graphData = buildGraphData(rawData);
            
            // Apply lineage-based layout with chronological constraints
            assignVerticalPositions(graphData.nodes, graphData.links);
            applyLineageBasedLayout(graphData.nodes, graphData.links);
            
            // Debug: Check everything step by step
            console.log('=== COMPLETE DEBUG ===');
            console.log(`Total nodes: ${graphData.nodes.length}`);
            console.log(`Total links: ${graphData.links.length}`);
            
            // Check if nodes have coordinates
            const nodesWithCoords = graphData.nodes.filter(n => n.x !== undefined && n.y !== undefined);
            console.log(`Nodes with coordinates: ${nodesWithCoords.length}`);
            
            // Sample coordinate check
            graphData.nodes.slice(0, 5).forEach(node => {
                console.log(`${node.name}: x=${node.x}, y=${node.y}, treeX=${node.treeX}, treeY=${node.treeY}`);
            });
            
            // Check if any nodes are positioned
            const xCoords = graphData.nodes.map(n => n.x).filter(x => x !== undefined && !isNaN(x));
            const yCoords = graphData.nodes.map(n => n.y).filter(y => y !== undefined && !isNaN(y));
            
            if (xCoords.length > 0 && yCoords.length > 0) {
                console.log(`X range: ${Math.min(...xCoords)} to ${Math.max(...xCoords)}`);
                console.log(`Y range: ${Math.min(...yCoords)} to ${Math.max(...yCoords)}`);
            } else {
                console.error('ERROR: No valid coordinates found!');
            }

            // Initial render
            renderVisualization(graphData);

            // Reset zoom to show all content - start simple
            console.log('Resetting zoom...');
            
            // Simple zoom reset - no fancy centering until we see the nodes
            const initialTransform = d3.zoomIdentity.translate(0, 0).scale(0.5);
            svg.call(zoom.transform, initialTransform);
            
            console.log('Zoom reset complete');
        }

        function filterData(filter) {
            if (filter === 'all') {
                return graphData;
            }

            const filteredNodes = graphData.nodes.filter(node => 
                node.primaryLineage === filter || 
                node.lineage.includes(filter) || 
                node.lineage.includes('All lineages')
            );
            const filteredNodeIds = new Set(filteredNodes.map(node => node.id));
            const filteredLinks = graphData.links.filter(link => 
                filteredNodeIds.has(link.source) && filteredNodeIds.has(link.target)
            );

            return {
                nodes: filteredNodes,
                links: filteredLinks
            };
        }

        function renderVisualization(data) {
            // Clear previous visualization
            g.selectAll('*').remove();

            // Calculate positions
            const levelGroups = d3.groups(data.nodes, d => d.level);
            const maxLevel = d3.max(levelGroups, d => d[0]);

            // New algorithmic positioning system
            convertAlgorithmicPositionsToPixels(data, width, height);
            
            function convertAlgorithmicPositionsToPixels(data, width, height) {
                const nodes = data.nodes;
                
                // Grid configuration - enhanced spacing for better vertical resolution
                const gridWidth = 220;  // Increased horizontal pixels per unit
                const gridHeight = 160; // Increased vertical space between generations (was 120px)
                const baseX = 100;      // larger left margin
                const baseY = 50;       // top margin
                
                // Convert tree positions to pixel coordinates - FIXED scaling
                nodes.forEach(node => {
                    let xPos, yPos;
                    
                    if (typeof node.treeX === 'number' && !isNaN(node.treeX)) {
                        // Use D3 tree coordinates directly (already processed for overlaps)
                        xPos = node.treeX / 100; // Light scaling for viewport
                    } else {
                        // Fallback: simple column by lineage
                        if (node.primaryLineage === 'Vimalamitra' || node.lineage?.includes('Vimalamitra')) {
                            xPos = 2;
                        } else if (node.primaryLineage === 'Padmasambhava' || node.lineage?.includes('Padmasambhava')) {
                            xPos = 6;
                        } else if (node.primaryLineage === 'Vairocana' || node.lineage?.includes('Vairocana')) {
                            xPos = 10;
                        } else {
                            xPos = 4; // Center for shared entities
                        }
                    }
                    
                    if (typeof node.treeY === 'number' && !isNaN(node.treeY)) {
                        // Use chronological Y coordinates directly with new spacing
                        yPos = node.treeY / 140; // Convert to layer units (matches 140px spacing from chronological constraints)
                    } else {
                        yPos = node.level || 0; // Fallback to timeLayer
                    }
                    
                    node.x = baseX + (xPos * gridWidth);
                    node.y = baseY + (yPos * gridHeight);
                    
                    // Debug key nodes
                    if (['Samantabhadra', 'Vimalamitra', 'Śākyamuni Buddha'].includes(node.name)) {
                        console.log(`${node.name}: treeX=${node.treeX} -> scaled=${xPos} -> pixel (${node.x}, ${node.y})`);
                    }
                });
            }

            // Create smooth curved links with arrowheads
            const links = g.selectAll('.link')
                .data(data.links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d => {
                    const source = data.nodes.find(n => n.id === d.source);
                    const target = data.nodes.find(n => n.id === d.target);
                    if (!source || !target) return '';
                    
                    // Simple, clean curved connections using single cubic Bézier curves
                    const sourceX = source.x;
                    const sourceY = source.y + 25; // Bottom of parent node
                    const targetX = target.x;
                    const targetY = target.y - 25; // Top of child node
                    
                    const deltaY = Math.abs(targetY - sourceY);
                    const controlOffset = Math.min(deltaY * 0.4, 80); // 40% of vertical distance, max 80px
                    
                    // Single smooth cubic Bézier curve for all connections
                    // Control points are directly below source and directly above target
                    const control1X = sourceX;
                    const control1Y = sourceY + controlOffset;
                    const control2X = targetX;
                    const control2Y = targetY - controlOffset;
                    
                    return `M${sourceX},${sourceY} C${control1X},${control1Y} ${control2X},${control2Y} ${targetX},${targetY}`;
                })
                .attr('stroke', d => {
                    const sourceNode = data.nodes.find(n => n.id === d.source);
                    return sourceNode ? getTransmissionColor(sourceNode.transmissionMode) : '#666';
                })
                .attr('marker-end', d => {
                    const sourceNode = data.nodes.find(n => n.id === d.source);
                    return sourceNode ? getArrowheadMarker(sourceNode.transmissionMode) : 'url(#arrowhead-default)';
                })
                .attr('stroke-width', 2)
                .attr('fill', 'none')
                .attr('opacity', 0.8);

            // Simplified rendering - no background zones or guides for now

            // Create node groups
            const nodeGroups = g.selectAll('.node-group')
                .data(data.nodes)
                .enter()
                .append('g')
                .attr('class', 'node-group')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            // Add node rectangles optimized for tree layout - wider to prevent overlap
            nodeGroups.append('rect')
                .attr('class', 'node')
                .attr('x', -90) // Wider nodes to accommodate longer names
                .attr('y', -25)
                .attr('width', 180) // Increased width
                .attr('height', 50)
                .attr('rx', 8)
                .attr('fill', d => getTransmissionColor(d.transmissionMode))
                .attr('stroke', '#333')
                .attr('stroke-width', 2)
                .attr('opacity', 0.95);

            // Add node text (name) - better text handling with longer names
            nodeGroups.append('text')
                .attr('class', 'node-text')
                .attr('y', -3)
                .attr('font-size', '11px')
                .text(d => d.name.length > 22 ? d.name.substring(0, 20) + '...' : d.name);

            // Add node text (dates) - smaller dates
            nodeGroups.append('text')
                .attr('class', 'node-date')
                .attr('y', 12)
                .attr('font-size', '9px')
                .text(d => d.dates && d.dates !== 'N/A' ? d.dates : '');

            // Add interaction events
            nodeGroups
                .on('mouseover', function(event, d) {
                    tooltip.classed('hidden', false)
                        .html(`
                            <strong>${d.name}</strong><br/>
                            ${d.tibetan ? `<em>${d.tibetan}</em><br/>` : ''}
                            <strong>Dates:</strong> ${d.dates}<br/>
                            <strong>Transmission:</strong> ${d.transmissionMode}<br/>
                            <strong>Lineage:</strong> ${d.lineage}<br/><br/>
                            ${d.description}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mousemove', function(event) {
                    tooltip.style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.classed('hidden', true);
                })
                .on('click', function(event, d) {
                    highlightLineage(d);
                });
        }

        function highlightLineage(node) {
            g.selectAll('.node').classed('highlighted', false);
            g.selectAll('.link').classed('highlighted', false);

            // Highlight connected nodes and links
            const connectedNodes = new Set([node.id]);
            
            // Find all ancestors
            function findAncestors(nodeId) {
                graphData.links.forEach(link => {
                    if (link.target === nodeId) {
                        connectedNodes.add(link.source);
                        findAncestors(link.source);
                    }
                });
            }

            // Find all descendants
            function findDescendants(nodeId) {
                graphData.links.forEach(link => {
                    if (link.source === nodeId) {
                        connectedNodes.add(link.target);
                        findDescendants(link.target);
                    }
                });
            }

            findAncestors(node.id);
            findDescendants(node.id);

            // Highlight nodes
            g.selectAll('.node-group').each(function(d) {
                if (connectedNodes.has(d.id)) {
                    d3.select(this).select('.node').classed('highlighted', true);
                }
            });

            // Highlight links
            g.selectAll('.link').each(function(d) {
                if (connectedNodes.has(d.source) && connectedNodes.has(d.target)) {
                    d3.select(this).classed('highlighted', true);
                }
            });
        }

        // Search functionality
        const searchInput = d3.select('#search');
        searchInput.on('input', function() {
            const searchTerm = this.value.toLowerCase();
            
            g.selectAll('.node-group').each(function(d) {
                const isMatch = d.name.toLowerCase().includes(searchTerm) || 
                               d.tibetan.toLowerCase().includes(searchTerm);
                d3.select(this).style('opacity', searchTerm === '' || isMatch ? 1 : 0.2);
            });
        });

        // Filter functionality
        d3.selectAll('.filter-btn').on('click', function() {
            d3.selectAll('.filter-btn').classed('active', false);
            d3.select(this).classed('active', true);
            
            currentFilter = this.dataset.filter;
            const filteredData = filterData(currentFilter);
            renderVisualization(filteredData);
        });

        // Start the application
        initializeApp();
    </script>
</body>
</html>