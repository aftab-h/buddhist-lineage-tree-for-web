<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dzogchen Lineage Tree - Interactive Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        #search {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 200px;
        }

        .filter-btn {
            padding: 6px 12px;
            margin: 2px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .filter-btn:hover {
            background: #f0f0f0;
        }

        .filter-btn.active {
            background: #4CAF50;
            color: white;
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
        }

        .node-text {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }

        .node-date {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            fill: #666;
        }

        .link {
            fill: none;
            stroke-width: 2px;
            stroke-opacity: 0.7;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            font-size: 13px;
            line-height: 1.4;
        }

        .hidden {
            display: none;
        }

        .highlighted {
            stroke-width: 4px !important;
            stroke: #ff6b35 !important;
        }

        .transmission-label {
            font-size: 16px;
            font-weight: bold;
            fill: #444;
            text-anchor: middle;
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <input type="text" id="search" placeholder="Search for a teacher...">
            <div>
                <button class="filter-btn active" data-filter="all">All Lineages</button>
                <button class="filter-btn" data-filter="Vimalamitra">Vimalamitra</button>
                <button class="filter-btn" data-filter="Vairocana">Vairocana</button>
                <button class="filter-btn" data-filter="Padmasambhava">Padmasambhava</button>
            </div>
        </div>

        <div id="legend">
            <h4 style="margin-top: 0;">Transmission Types</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #4FC3F7;"></div>
                <span>Mind-Mind (Primordial)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #BA68C8;"></div>
                <span>Symbolic Transmission</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #81C784;"></div>
                <span>Aural Lineage</span>
            </div>
        </div>

        <div class="tooltip hidden" id="tooltip"></div>
        <svg id="svg"></svg>
    </div>

    <script>
        // Load CSV data dynamically
        let graphData = null;
        let currentFilter = 'all';

        async function loadCSVData() {
            try {
                const response = await fetch('./data/dzogchen_lineage.csv');
                const csvText = await response.text();
                return csvText;
            } catch (error) {
                console.error('Error loading CSV:', error);
                return null;
            }
        }

        // Parse CSV data
        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = [];
                let inQuotes = false;
                let currentValue = '';
                
                for (let char of line) {
                    if (char === '"' && !inQuotes) {
                        inQuotes = true;
                    } else if (char === '"' && inQuotes) {
                        inQuotes = false;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue.trim());
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                values.push(currentValue.trim());

                const obj = {};
                headers.forEach((header, i) => {
                    obj[header.trim()] = values[i] || '';
                });
                return obj;
            });
        }

        // Define columns within each transmission type zone
        function defineTransmissionColumns(nodes) {
            // Define columns within each transmission zone
            const transmissionColumns = {
                // Blue zone (Mind-to-Mind) - single central column
                mindToMind: {
                    column1: [
                        'Samantabhadra',
                        'Samantabhadrī', 
                        'Buddhas of the Five Families',
                        'Supreme Emanation Blessing',
                        'Sublime Wisdom Emanation (Vajradhara)',
                        'Vajrasattva',
                        'Vajrapāṇi',
                        'Cheu Nangwa Dampa Samkyi Mikhyapa',
                        'Śākyamuni Buddha'
                    ]
                },
                
                // Purple zone (Symbolic) - three main columns  
                symbolic: {
                    vimalamitra: ['Garab Dorje', 'Mañjuśrimitra', 'Śrī Siṃha', 'Jñānasūtra', 'Vimalamitra'],
                    padmasambhava: ['Garab Dorje', 'Mañjuśrimitra', 'Śrī Siṃha', 'Padmasambhava'],
                    vairocana: ['Garab Dorje', 'Śrī Siṃha', 'Vairocana']
                },
                
                // Green zone (Aural) - three descendant columns
                aural: {
                    vimalamitra: [
                        'King Trisong Detsen', 'Nyang Tingzin Zanpo', 'Bé Lodrö Wangchuk', 
                        'Drom Rinchen Bar', 'Dangma Lhundrup Gyaltsen', 'Chetsun Sengge Wangchuk',
                        'Zhangtön Tashi Dorje', 'Nyima Bum', 'Guru Jober', 'Trulzhik Senggé Gyabpa',
                        'Melong Dorje', 'Kumārarāja', 'Longchenpa Drime Özer'
                    ],
                    padmasambhava: [
                        'Yeshe Tsogyel', 'Princess Lhacam Pema Sel', 'Pema Ledreltsel/Tsultrim Dorje',
                        'Tulku Legden/Gyalse Legpa', 'Karmapa Rangjung Dorje', 'Gyalwa Yungtön Dorje',
                        'Meban Rinchen Lingpa', 'Rigzin Gödem', 'Jadralwa Zöpa'
                    ],
                    vairocana: [
                        'Pang Sang-gyé Gönpo', 'Ngenlam Jangchub Gyaltsen', 'Zadam Rinchenyik',
                        'Khugyur Salwaichok', 'Yudra Nyingpo', 'Aro Yeshe Jungne', 'Setsün',
                        'Jangtön Namdak', 'Kadampa Deshek'
                    ]
                }
            };

            // Mark nodes with their transmission zone and column
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            Object.keys(transmissionColumns).forEach(transmissionType => {
                Object.keys(transmissionColumns[transmissionType]).forEach(columnName => {
                    transmissionColumns[transmissionType][columnName].forEach((nodeName, index) => {
                        const node = nodeMap.get(nodeName);
                        if (node) {
                            node.transmissionZone = transmissionType;
                            node.columnName = columnName;
                            node.positionInColumn = index;
                            node.isInMainColumn = true;
                        }
                    });
                });
            });

            return transmissionColumns;
        }
        
        // Mark all nodes with proper lineage affiliation for filtering
        function markAllNodesWithLineage(nodes, links) {
            // Define the main lineage ancestors
            const lineageAncestors = {
                'Vimalamitra': ['Vimalamitra', 'Jñānasūtra', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Padmasambhava': ['Padmasambhava', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Vairocana': ['Vairocana', 'Śrī Siṃha', 'Garab Dorje']
            };
            
            // Helper function to trace lineage ancestry
            function findLineageAncestry(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return null; // Prevent cycles
                visited.add(nodeId);
                
                // Check if this node is a lineage ancestor
                for (const [lineage, ancestors] of Object.entries(lineageAncestors)) {
                    if (ancestors.includes(nodeId)) {
                        return lineage;
                    }
                }
                
                // Check parents recursively
                const parentLinks = links.filter(link => link.target === nodeId);
                for (const link of parentLinks) {
                    const parentLineage = findLineageAncestry(link.source, new Set(visited));
                    if (parentLineage) return parentLineage;
                }
                
                return null;
            }
            
            // Assign lineage to all nodes
            nodes.forEach(node => {
                if (!node.primaryLineage) {
                    // First try to use existing lineage field
                    if (node.lineage && node.lineage !== 'All lineages') {
                        const lineageParts = node.lineage.split(';').map(l => l.trim());
                        for (const part of lineageParts) {
                            if (part.includes('Vimalamitra')) {
                                node.primaryLineage = 'Vimalamitra';
                                break;
                            } else if (part.includes('Padmasambhava')) {
                                node.primaryLineage = 'Padmasambhava';
                                break;
                            } else if (part.includes('Vairocana')) {
                                node.primaryLineage = 'Vairocana';
                                break;
                            }
                        }
                    }
                    
                    // If still no lineage, trace ancestry
                    if (!node.primaryLineage) {
                        node.primaryLineage = findLineageAncestry(node.id) || 'All lineages';
                    }
                }
            });
        }

        // Build node and link data
        function buildGraphData(data) {
            const nodes = new Map();
            const links = [];

            // Create nodes
            data.forEach(person => {
                if (!nodes.has(person.Name_English)) {
                    nodes.set(person.Name_English, {
                        id: person.Name_English,
                        name: person.Name_English,
                        tibetan: person.Name_Wylie_Tibetan,
                        dates: person.Dates,
                        description: person.Description_English,
                        transmissionMode: person.Transmission_Mode,
                        lineage: person.Lineage,
                        level: 0,
                        children: []
                    });
                }
            });

            // Create links
            data.forEach(person => {
                if (person.Received_Teachings_From) {
                    const teachers = person.Received_Teachings_From.split(';').map(t => t.trim());
                    teachers.forEach(teacher => {
                        if (teacher && nodes.has(teacher) && nodes.has(person.Name_English)) {
                            links.push({
                                source: teacher,
                                target: person.Name_English,
                                lineage: person.Lineage
                            });
                            nodes.get(teacher).children.push(person.Name_English);
                        }
                    });
                }
            });

            // Define transmission columns and mark nodes
            const nodeArray = Array.from(nodes.values());
            const transmissionColumns = defineTransmissionColumns(nodeArray);
            
            // Ensure all nodes have proper lineage marking for filtering
            markAllNodesWithLineage(nodeArray, links);
            
            return {
                nodes: nodeArray,
                links: links,
                transmissionColumns: transmissionColumns
            };
        }

        // Get color based on transmission mode
        function getTransmissionColor(transmissionMode) {
            switch (transmissionMode) {
                case 'Mind to Mind':
                    return '#4FC3F7'; // Blue for Mind-to-Mind transmission
                case 'Symbolic':
                    return '#BA68C8'; // Purple for Symbolic transmission
                case 'Aural':
                    return '#81C784'; // Green for Aural transmission
                default:
                    return '#E0E0E0'; // Gray for unknown/mixed
            }
        }

        // Parse dates from various formats and return approximate year
        function parseDate(dateString) {
            if (!dateString || dateString === 'N/A' || dateString === 'Date unknown' || dateString.includes('Beyond time')) {
                return null; // No date available
            }
            
            // Handle century formats like "8th century", "7th to 8th centuries"
            const centuryMatch = dateString.match(/(\d+)(?:th|st|nd|rd)\s+century/i);
            if (centuryMatch) {
                const century = parseInt(centuryMatch[1]);
                return (century - 1) * 100 + 50; // Middle of century (8th century = 750)
            }
            
            // Handle ranges like "1308-1364", "8th-9th centuries"
            const rangeMatch = dateString.match(/(\d{3,4})-(\d{3,4})/);
            if (rangeMatch) {
                return parseInt(rangeMatch[1]); // Take the start year
            }
            
            // Handle single years or "8th century BCE"
            const yearMatch = dateString.match(/(\d{3,4})/);
            if (yearMatch) {
                const year = parseInt(yearMatch[1]);
                // Handle BCE dates
                return dateString.includes('BCE') ? -year : year;
            }
            
            return null; // Couldn't parse
        }

        // Assign levels using three-tier chronological system
        function assignLevels(nodes, links) {
            // Parse dates for all nodes
            nodes.forEach(node => {
                node.parsedDate = parseDate(node.dates);
            });

            // Separate nodes by transmission mode
            const mindToMindNodes = nodes.filter(node => node.transmissionMode === 'Mind to Mind');
            const symbolicNodes = nodes.filter(node => node.transmissionMode === 'Symbolic');
            const auralNodes = nodes.filter(node => node.transmissionMode === 'Aural');

            // Build parent-child relationships for symbolic nodes (relationship-based positioning)
            const childrenMap = new Map();
            const parentsMap = new Map();
            
            symbolicNodes.forEach(node => {
                childrenMap.set(node.id, []);
                parentsMap.set(node.id, []);
            });
            
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode && 
                    sourceNode.transmissionMode === 'Symbolic' && 
                    targetNode.transmissionMode === 'Symbolic') {
                    childrenMap.get(link.source).push(link.target);
                    parentsMap.get(link.target).push(link.source);
                }
            });

            // TIER 1: Mind to Mind (Levels 0-3) - Primordial/Timeless with specific hierarchy
            mindToMindNodes.forEach(node => {
                switch (node.name) {
                    case 'Samantabhadra':
                    case 'Samantabhadrī':
                        node.level = 0; // Very top
                        break;
                    case 'Buddhas of the Five Families':
                        node.level = 1; // Below primordial couple
                        break;
                    case 'Supreme Emanation Blessing':
                    case 'Sublime Wisdom Emanation (Vajradhara)':
                    case 'Vajradhara':
                        node.level = 2; // Below Five Buddha Families
                        break;
                    case 'Vajrapāṇi':
                    case 'Vajrasattva':
                    case 'Cheu Nangwa Dampa Samkyi Mikhyapa':
                        node.level = 3; // Below Vajradhara/Supreme Emanation Blessing
                        break;
                    case 'Śākyamuni Buddha':
                        node.level = 4; // Below Cheu Nangwa Dampa Samkyi Mikhyapa
                        break;
                    default:
                        // Any other Mind to Mind entities
                        node.level = 3; // Default to level 3
                        break;
                }
            });

            // TIER 2: Symbolic (Levels 5-7) - Relationship-based
            const symbolicRoots = symbolicNodes.filter(node => 
                parentsMap.get(node.id)?.length === 0 || !parentsMap.has(node.id)
            );
            
            const queue = symbolicRoots.map(root => ({ id: root.id, level: 5 }));
            const processed = new Set();

            while (queue.length > 0) {
                const { id, level } = queue.shift();
                
                if (processed.has(id)) continue;
                processed.add(id);
                
                const node = symbolicNodes.find(n => n.id === id);
                if (node) {
                    node.level = Math.min(level, 7); // Cap at level 7
                    
                    // Add children
                    const children = childrenMap.get(id) || [];
                    children.forEach(childId => {
                        if (!processed.has(childId)) {
                            queue.push({ id: childId, level: level + 1 });
                        }
                    });
                }
            }

            // TIER 3: Aural (Levels 7+) - Chronologically sorted
            auralNodes.sort((a, b) => {
                const dateA = a.parsedDate || 9999; // Put undated at end
                const dateB = b.parsedDate || 9999;
                return dateA - dateB;
            });

            // Group aural nodes by finer time periods with smart density detection
            function createTimeGroups(auralNodes) {
                const timeGroups = [];
                let currentGroup = [];
                let currentPeriod = null;
                const QUARTER_CENTURY = 25; // Start with 25-year periods
                const MAX_NODES_PER_GROUP = 4; // Maximum nodes before subdividing
                
                auralNodes.forEach(node => {
                    const date = node.parsedDate;
                    const period = date ? Math.floor(date / QUARTER_CENTURY) * QUARTER_CENTURY : 9999;
                    
                    if (currentPeriod === null || period === currentPeriod) {
                        currentGroup.push(node);
                        currentPeriod = period;
                    } else {
                        if (currentGroup.length > 0) {
                            // Check if group is too crowded and needs subdivision
                            if (currentGroup.length > MAX_NODES_PER_GROUP) {
                                const subdivided = subdivideGroup(currentGroup, 10); // 10-year periods
                                timeGroups.push(...subdivided);
                            } else {
                                timeGroups.push([...currentGroup]);
                            }
                        }
                        currentGroup = [node];
                        currentPeriod = period;
                    }
                });
                
                // Handle the last group
                if (currentGroup.length > 0) {
                    if (currentGroup.length > MAX_NODES_PER_GROUP) {
                        const subdivided = subdivideGroup(currentGroup, 10);
                        timeGroups.push(...subdivided);
                    } else {
                        timeGroups.push(currentGroup);
                    }
                }
                
                return timeGroups;
            }
            
            // Subdivide overcrowded groups into smaller time periods
            function subdivideGroup(group, yearSpan) {
                const subGroups = [];
                let currentSubGroup = [];
                let currentSubPeriod = null;
                
                group.forEach(node => {
                    const date = node.parsedDate;
                    const period = date ? Math.floor(date / yearSpan) * yearSpan : 9999;
                    
                    if (currentSubPeriod === null || period === currentSubPeriod) {
                        currentSubGroup.push(node);
                        currentSubPeriod = period;
                    } else {
                        if (currentSubGroup.length > 0) {
                            subGroups.push([...currentSubGroup]);
                        }
                        currentSubGroup = [node];
                        currentSubPeriod = period;
                    }
                });
                
                if (currentSubGroup.length > 0) {
                    subGroups.push(currentSubGroup);
                }
                
                return subGroups;
            }
            
            // Create time groups with enhanced resolution
            const timeGroups = createTimeGroups(auralNodes);

            // Assign levels to aural nodes with transmission-aware positioning
            let currentLevel = 8;
            timeGroups.forEach((group, groupIndex) => {
                if (group.length <= 2) {
                    // Small groups can share a level
                    group.sort((a, b) => {
                        const dateA = a.parsedDate || 9999;
                        const dateB = b.parsedDate || 9999;
                        if (dateA !== dateB) return dateA - dateB;
                        return a.lineage.localeCompare(b.lineage);
                    });
                    
                    group.forEach(node => {
                        node.level = currentLevel;
                    });
                    currentLevel++;
                } else {
                    // Larger groups need transmission-aware sub-positioning
                    const subLevels = arrangeByTransmission(group, links);
                    subLevels.forEach(subGroup => {
                        subGroup.forEach(node => {
                            node.level = currentLevel;
                        });
                        currentLevel++;
                    });
                }
            });
            
            // Helper function to arrange nodes by transmission relationships
            function arrangeByTransmission(nodes, links) {
                const nodeMap = new Map(nodes.map(n => [n.id, n]));
                const children = new Map();
                const parents = new Map();
                
                // Build relationships within this group
                nodes.forEach(node => {
                    children.set(node.id, []);
                    parents.set(node.id, []);
                });
                
                links.forEach(link => {
                    if (nodeMap.has(link.source) && nodeMap.has(link.target)) {
                        children.get(link.source).push(link.target);
                        parents.get(link.target).push(link.source);
                    }
                });
                
                // Find nodes with no parents in this group (teachers)
                const roots = nodes.filter(node => parents.get(node.id).length === 0);
                const remaining = nodes.filter(node => parents.get(node.id).length > 0);
                
                const levels = [];
                if (roots.length > 0) {
                    levels.push(roots.sort((a, b) => (a.parsedDate || 9999) - (b.parsedDate || 9999)));
                }
                if (remaining.length > 0) {
                    levels.push(remaining.sort((a, b) => (a.parsedDate || 9999) - (b.parsedDate || 9999)));
                }
                
                return levels.length > 0 ? levels : [nodes];
            }

            return nodes;
        }

        // Initialize visualization
        const container = d3.select('#container');
        const svg = d3.select('#svg');
        const tooltip = d3.select('#tooltip');

        const width = window.innerWidth;
        const height = window.innerHeight;

        svg.attr('width', width).attr('height', height);

        const g = svg.append('g');

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);

        // Initialize the application
        async function initializeApp() {
            const csvData = await loadCSVData();
            if (!csvData) {
                console.error('Failed to load CSV data');
                return;
            }

            // Parse data and build graph
            const rawData = parseCSV(csvData);
            graphData = buildGraphData(rawData);
            assignLevels(graphData.nodes, graphData.links);

            // Initial render
            renderVisualization(graphData);

            // Center the view initially at top portion of the map
            const bounds = g.node().getBBox();
            const fullWidth = window.innerWidth;
            const fullHeight = window.innerHeight;
            const scale = 0.6;
            const translateX = (fullWidth - bounds.width * scale) / 2 - bounds.x * scale;
            // Position at top portion - show top 25% of the visualization
            const translateY = -bounds.y * scale + 100; // Start from top with some padding
            
            const initialTransform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
            svg.transition().duration(750).call(zoom.transform, initialTransform);
        }

        function filterData(filter) {
            if (filter === 'all') {
                return graphData;
            }

            const filteredNodes = graphData.nodes.filter(node => 
                node.primaryLineage === filter || 
                node.lineage.includes(filter) || 
                node.lineage.includes('All lineages')
            );
            const filteredNodeIds = new Set(filteredNodes.map(node => node.id));
            const filteredLinks = graphData.links.filter(link => 
                filteredNodeIds.has(link.source) && filteredNodeIds.has(link.target)
            );

            return {
                nodes: filteredNodes,
                links: filteredLinks,
                transmissionColumns: graphData.transmissionColumns
            };
        }

        function renderVisualization(data) {
            // Clear previous visualization
            g.selectAll('*').remove();

            // Calculate positions
            const levelGroups = d3.groups(data.nodes, d => d.level);
            const maxLevel = d3.max(levelGroups, d => d[0]);

            // Grid-based positioning system
            positionNodesInGrid(data, width, height);
            
            function positionNodesInGrid(data, width, height) {
                const nodes = data.nodes;
                const transmissionColumns = data.transmissionColumns;
                
                // Grid configuration
                const gridWidth = 90;  // pixels per grid column
                const gridHeight = 120; // pixels per grid row
                const baseX = 100;     // left margin
                const baseY = 100;     // top margin
                
                // Main lineage columns with 10-column spacing
                const mainColumns = {
                    vimalamitra: 10,
                    padmasambhava: 20,
                    vairocana: 30
                };
                
                // Assign grid positions to all nodes
                assignGridPositions(nodes, transmissionColumns, mainColumns, data.links);
                
                // Convert grid positions to pixel coordinates
                nodes.forEach(node => {
                    if (typeof node.gridCol === 'number' && typeof node.gridRow === 'number') {
                        node.x = baseX + (node.gridCol * gridWidth);
                        node.y = baseY + (node.gridRow * gridHeight);
                    } else {
                        // Fallback for nodes without grid position
                        console.warn('Node without grid position:', node.name);
                        node.x = baseX + (20 * gridWidth); // Default position
                        node.y = baseY + (node.level * gridHeight);
                    }
                });
            }
            
            function assignGridPositions(nodes, transmissionColumns, mainColumns, links) {
                // First, assign main lineage nodes to their primary columns
                Object.keys(transmissionColumns).forEach(transmissionZone => {
                    Object.keys(transmissionColumns[transmissionZone]).forEach(columnName => {
                        const gridCol = mainColumns[columnName];
                        if (gridCol) {
                            transmissionColumns[transmissionZone][columnName].forEach(nodeName => {
                                const node = nodes.find(n => n.id === nodeName);
                                if (node) {
                                    node.gridCol = gridCol;
                                    node.gridRow = node.level; // Use existing level system for rows
                                    node.isInMainColumn = true;
                                }
                            });
                        }
                    });
                });
                
                // Handle nodes not in main columns (side branches)
                const sideNodes = nodes.filter(node => !node.isInMainColumn);
                const parentChildMap = new Map(); // parent -> [children]
                
                // Build parent-child relationships
                links.forEach(link => {
                    if (!parentChildMap.has(link.source)) {
                        parentChildMap.set(link.source, []);
                    }
                    parentChildMap.get(link.source).push(link.target);
                });
                
                // Assign positions to side branches
                sideNodes.forEach(node => {
                    const parentLink = links.find(link => link.target === node.id);
                    if (parentLink) {
                        const parent = nodes.find(n => n.id === parentLink.source);
                        if (parent && typeof parent.gridCol === 'number') {
                            // Position relative to parent
                            const siblings = parentChildMap.get(parent.id) || [];
                            const siblingIndex = siblings.indexOf(node.id);
                            
                            // Spread siblings around parent column
                            if (siblings.length === 1) {
                                node.gridCol = parent.gridCol + 1; // Single child goes right
                            } else {
                                // Multiple children spread left and right
                                const offset = Math.ceil((siblingIndex + 1) / 2) * (siblingIndex % 2 === 0 ? 1 : -1);
                                node.gridCol = parent.gridCol + offset;
                            }
                            node.gridRow = node.level; // Use existing level system
                        } else {
                            // Parent not positioned, use fallback
                            node.gridCol = 35; // Far right area
                            node.gridRow = node.level;
                        }
                    } else {
                        // No parent found, orphaned node
                        node.gridCol = 35; // Far right area  
                        node.gridRow = node.level;
                    }
                });
            }

            // Create links
            const links = g.selectAll('.link')
                .data(data.links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d => {
                    const source = data.nodes.find(n => n.id === d.source);
                    const target = data.nodes.find(n => n.id === d.target);
                    if (!source || !target) return '';
                    
                    const path = d3.path();
                    path.moveTo(source.x, source.y + 30);
                    path.bezierCurveTo(
                        source.x, source.y + 60,
                        target.x, target.y - 60,
                        target.x, target.y - 30
                    );
                    return path.toString();
                })
                .attr('stroke', d => {
                    const sourceNode = data.nodes.find(n => n.id === d.source);
                    return sourceNode ? getTransmissionColor(sourceNode.transmissionMode) : '#E0E0E0';
                })
                .attr('stroke-width', 2)
                .attr('fill', 'none');

            // Create grid-based transmission zone backgrounds
            const gridWidth = 90;
            const baseX = 100;
            const baseY = 100;
            const zoneColors = {
                mindToMind: 'rgba(79, 195, 247, 0.1)',
                symbolic: 'rgba(186, 104, 200, 0.1)', 
                aural: 'rgba(129, 199, 132, 0.1)'
            };
            
            // Create backgrounds for transmission zones
            Object.keys(zoneColors).forEach(zoneName => {
                const zoneNodes = data.nodes.filter(node => {
                    if (zoneName === 'mindToMind') return node.transmissionMode === 'Mind to Mind';
                    if (zoneName === 'symbolic') return node.transmissionMode === 'Symbolic';
                    if (zoneName === 'aural') return node.transmissionMode === 'Aural';
                    return false;
                });
                
                if (zoneNodes.length > 0) {
                    const minY = Math.min(...zoneNodes.map(n => n.y)) - 40;
                    const maxY = Math.max(...zoneNodes.map(n => n.y)) + 80;
                    
                    g.append('rect')
                        .attr('class', 'transmission-zone-background')
                        .attr('x', baseX)
                        .attr('y', minY)
                        .attr('width', 40 * gridWidth) // Cover all 40 grid columns
                        .attr('height', maxY - minY)
                        .attr('fill', zoneColors[zoneName])
                        .attr('stroke', 'rgba(150, 150, 150, 0.2)')
                        .attr('stroke-width', 1)
                        .attr('rx', 8);
                    
                    // Add zone label
                    let zoneLabel = '';
                    if (zoneName === 'mindToMind') zoneLabel = 'Mind-to-Mind Transmission';
                    if (zoneName === 'symbolic') zoneLabel = 'Symbolic Transmission';
                    if (zoneName === 'aural') zoneLabel = 'Aural Lineage';
                    
                    g.append('text')
                        .attr('class', 'zone-label')
                        .attr('x', baseX + 20)
                        .attr('y', minY + 25)
                        .attr('font-size', '16px')
                        .attr('font-weight', 'bold')
                        .attr('fill', '#444')
                        .text(zoneLabel);
                }
            });
            
            // Add main lineage column guides
            const mainColumns = [10, 20, 30]; // Vimalamitra, Padmasambhava, Vairocana
            const columnLabels = ['Vimalamitra', 'Padmasambhava', 'Vairocana'];
            
            mainColumns.forEach((col, index) => {
                const x = baseX + (col * gridWidth);
                
                // Column guide line
                g.append('line')
                    .attr('class', 'column-guide')
                    .attr('x1', x)
                    .attr('y1', baseY)
                    .attr('x2', x)
                    .attr('y2', height - 100)
                    .attr('stroke', 'rgba(100, 100, 100, 0.2)')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                // Column label
                g.append('text')
                    .attr('class', 'column-label')
                    .attr('x', x)
                    .attr('y', baseY - 10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .attr('fill', '#666')
                    .text(columnLabels[index] + ' Lineage');
            });

            // Create node groups
            const nodeGroups = g.selectAll('.node-group')
                .data(data.nodes)
                .enter()
                .append('g')
                .attr('class', 'node-group')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            // Add node rectangles
            nodeGroups.append('rect')
                .attr('class', 'node')
                .attr('x', -80)
                .attr('y', -30)
                .attr('width', 160)
                .attr('height', 60)
                .attr('rx', 8)
                .attr('fill', d => getTransmissionColor(d.transmissionMode))
                .attr('stroke', '#333')
                .attr('stroke-width', 1);

            // Add node text (name)
            nodeGroups.append('text')
                .attr('class', 'node-text')
                .attr('y', -5)
                .text(d => d.name.length > 20 ? d.name.substring(0, 18) + '...' : d.name);

            // Add node text (dates)
            nodeGroups.append('text')
                .attr('class', 'node-date')
                .attr('y', 15)
                .text(d => d.dates);

            // Add interaction events
            nodeGroups
                .on('mouseover', function(event, d) {
                    tooltip.classed('hidden', false)
                        .html(`
                            <strong>${d.name}</strong><br/>
                            ${d.tibetan ? `<em>${d.tibetan}</em><br/>` : ''}
                            <strong>Dates:</strong> ${d.dates}<br/>
                            <strong>Transmission:</strong> ${d.transmissionMode}<br/>
                            <strong>Lineage:</strong> ${d.lineage}<br/><br/>
                            ${d.description}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mousemove', function(event) {
                    tooltip.style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.classed('hidden', true);
                })
                .on('click', function(event, d) {
                    highlightLineage(d);
                });
        }

        function highlightLineage(node) {
            g.selectAll('.node').classed('highlighted', false);
            g.selectAll('.link').classed('highlighted', false);

            // Highlight connected nodes and links
            const connectedNodes = new Set([node.id]);
            
            // Find all ancestors
            function findAncestors(nodeId) {
                graphData.links.forEach(link => {
                    if (link.target === nodeId) {
                        connectedNodes.add(link.source);
                        findAncestors(link.source);
                    }
                });
            }

            // Find all descendants
            function findDescendants(nodeId) {
                graphData.links.forEach(link => {
                    if (link.source === nodeId) {
                        connectedNodes.add(link.target);
                        findDescendants(link.target);
                    }
                });
            }

            findAncestors(node.id);
            findDescendants(node.id);

            // Highlight nodes
            g.selectAll('.node-group').each(function(d) {
                if (connectedNodes.has(d.id)) {
                    d3.select(this).select('.node').classed('highlighted', true);
                }
            });

            // Highlight links
            g.selectAll('.link').each(function(d) {
                if (connectedNodes.has(d.source) && connectedNodes.has(d.target)) {
                    d3.select(this).classed('highlighted', true);
                }
            });
        }

        // Search functionality
        const searchInput = d3.select('#search');
        searchInput.on('input', function() {
            const searchTerm = this.value.toLowerCase();
            
            g.selectAll('.node-group').each(function(d) {
                const isMatch = d.name.toLowerCase().includes(searchTerm) || 
                               d.tibetan.toLowerCase().includes(searchTerm);
                d3.select(this).style('opacity', searchTerm === '' || isMatch ? 1 : 0.2);
            });
        });

        // Filter functionality
        d3.selectAll('.filter-btn').on('click', function() {
            d3.selectAll('.filter-btn').classed('active', false);
            d3.select(this).classed('active', true);
            
            currentFilter = this.dataset.filter;
            const filteredData = filterData(currentFilter);
            renderVisualization(filteredData);
        });

        // Start the application
        initializeApp();
    </script>
</body>
</html>