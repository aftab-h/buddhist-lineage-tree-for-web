<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Buddhist Lineage - Temporal Playhead Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Tibetan:wght@400;600&family=Noto+Sans+SC:wght@400;600&display=swap');

        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', 'Noto Sans Tibetan', 'Noto Sans SC', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
            touch-action: none; /* Prevent any touch gestures on body */
            user-select: none; /* Prevent text selection on mobile */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        svg {
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            touch-action: manipulation; /* Allow D3 pan/zoom but prevent browser zoom */
        }

        /* Node Styles */
        .node {
            cursor: pointer;
            stroke-width: 1.5px;
            opacity: 0.9;
        }

        /* Default white color for unknown/invalid transmission modes */
        .node {
            fill: #ffffff;
            stroke: #cccccc;
        }

        .node.mind-to-mind {
            fill: #4a90e2;
            stroke: #357abd;
        }

        .node.symbolic {
            fill: #9b59b6;
            stroke: #7d3c98;
        }

        .node.aural {
            fill: #27ae60;
            stroke: #1e8449;
        }

        .node:hover {
            opacity: 1;
            stroke-width: 3px;
        }

        /* Link Styles */
        .link {
            fill: none;
            stroke-width: 1.5px;
            opacity: 0.7;
        }

        .link.teaching {
            stroke: #ffffff;
            stroke-width: 1px;
        }

        .link.incarnation {
            stroke: #888888;
            stroke-dasharray: 2,2;
        }

        .link.family {
            stroke: #cd853f;
            stroke-dasharray: 5,3;
        }

        .link.emanation {
            stroke: #ffd700;
            stroke-dasharray: 1,1;
        }

        /* Traceback highlighting styles */
        .node.traced {
            stroke: #ffff00 !important;
            stroke-width: 3px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 10px #ffff00);
        }

        .node.traced.target {
            stroke-width: 5px !important;
            filter: drop-shadow(0 0 15px #ffff00) brightness(1.3) !important;
        }

        /* Base traced link style */
        .link.traced {
            stroke: #ffff00 !important;
            stroke-width: 4px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 8px #ffff00);
        }

        /* Preserve relationship-specific dash patterns when highlighted */
        .link.teaching.traced {
            stroke-dasharray: none; /* Solid line for teaching */
        }

        .link.incarnation.traced {
            stroke-dasharray: 4,4; /* Larger dots for incarnation when highlighted */
        }

        .link.family.traced {
            stroke-dasharray: 10,6; /* Larger dashes for family when highlighted */
        }

        .link.emanation.traced {
            stroke-dasharray: 2,2; /* Small dots for emanation when highlighted */
        }

        /* Popup card styles */
        .popup-card {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1500;
            border: 1px solid #e0e0e0;
            animation: popupFadeIn 0.2s ease-out;
        }

        .popup-card.hidden {
            display: none;
        }

        @keyframes popupFadeIn {
            0% {
                opacity: 0;
                transform: translateY(-10px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .popup-header {
            padding: 15px 15px 10px 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .popup-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .popup-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .popup-close:hover {
            color: #333;
            background: #f0f0f0;
            border-radius: 3px;
        }

        .popup-body {
            padding: 15px;
        }

        /* Image carousel styles */
        .popup-images {
            margin-bottom: 15px;
        }

        .image-carousel {
            position: relative;
            width: 100%;
            border-radius: 6px;
            background: #f5f5f5;
            overflow: hidden;
        }

        .carousel-container {
            display: flex;
            transition: transform 0.3s ease;
            min-height: 200px;
        }

        .carousel-image {
            width: 100%;
            max-width: 100%;
            height: auto;
            max-height: 300px;
            object-fit: contain;
            flex-shrink: 0;
            display: block;
            margin: auto 0;
        }

        .carousel-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: opacity 0.2s;
        }

        .carousel-nav:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        .carousel-prev {
            left: 10px;
        }

        .carousel-next {
            right: 10px;
        }

        .carousel-dots {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-top: 8px;
        }

        .carousel-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ddd;
            cursor: pointer;
            transition: background 0.2s;
        }

        .carousel-dot.active {
            background: #007bff;
        }

        .carousel-dot:hover {
            background: #0056b3;
        }

        #popup-tibetan {
            font-family: 'Noto Sans Tibetan', sans-serif;
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-style: italic;
        }

        /* Language-specific text styling */
        .tibetan-text {
            font-family: 'Noto Sans Tibetan', sans-serif !important;
            font-size: 16px;
            line-height: 1.4;
        }

        .chinese-text {
            font-family: 'Noto Sans SC', sans-serif !important;
            font-size: 16px;
            line-height: 1.4;
        }

        .english-text {
            font-family: 'Arial', sans-serif !important;
        }

        /* Prevent accidental zoom on UI elements */
        .controls, .popup-card, #playback-bar, #legend-icon, #controls-icon {
            touch-action: manipulation !important;
        }

        #popup-dates {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        #popup-description {
            font-size: 14px;
            line-height: 1.5;
            color: #333;
        }

        #popup-img-subtext {
            font-size: 12px;
            font-style: italic;
            color: #666;
            margin-top: 5px;
            margin-bottom: 10px;
            text-align: center;
        }

        #popup-links {
            font-size: 14px;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .popup-links h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }

        .popup-links a {
            color: #4a90e2;
            text-decoration: none;
            margin-right: 15px;
            display: inline-block;
            margin-bottom: 5px;
        }

        .popup-links a:hover {
            text-decoration: underline;
            color: #357abd;
        }

        .node.dimmed {
            opacity: 0.2 !important;
        }

        .link.dimmed {
            opacity: 0.1 !important;
        }

        /* Controls Icon */
        #controls-icon {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            width: 40px;
            height: 40px;
            background: rgba(20, 20, 20, 0.9);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            border: 1px solid #333;
        }

        #controls-icon:hover {
            background: rgba(30, 30, 30, 0.95);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transform: scale(1.05);
        }

        #controls-icon svg {
            width: 18px;
            height: 18px;
            fill: #fff;
            transition: fill 0.2s ease;
        }

        #controls-icon:hover svg {
            fill: #4a90e2;
        }

        /* Controls Panel */
        .controls {
            position: fixed;
            top: 70px;
            left: 10px;
            z-index: 1000;
            background: rgba(20, 20, 20, 0.9);
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            max-width: calc(100vw - 20px);
            box-sizing: border-box;
            transform: translateX(-100%);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 250px;
            border: 1px solid #333;
        }

        .controls.show {
            transform: translateX(0);
            opacity: 1;
            visibility: visible;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #ffffff;
        }

        .control-group button {
            margin-right: 5px;
            margin-bottom: 5px;
            padding: 5px 10px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
        }

        .control-group button:hover {
            background: #444;
        }

        .control-group button.active {
            background: #4a90e2;
            border-color: #357abd;
            color: #fff;
        }

        .control-group select {
            background: rgba(60, 60, 60, 0.8);
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
            min-width: 100px;
            cursor: pointer;
        }

        .control-group select:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 5px rgba(74, 144, 226, 0.3);
        }

        .control-group select option {
            background: #444;
            color: #fff;
            padding: 4px 8px;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        /* Search functionality styles */
        .search-container {
            position: relative;
            margin-bottom: 10px;
        }

        #search {
            width: 100%;
            padding: 8px 80px 8px 10px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
            background: #444;
            color: #fff;
        }

        #search:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
        }

        .search-navigation {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(68, 68, 68, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #666;
        }

        .search-nav-btn {
            background: none;
            border: none;
            font-size: 16px;
            font-weight: bold;
            color: #ccc;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 2px;
            line-height: 1;
        }

        .search-nav-btn:hover {
            background: #555;
            color: #fff;
        }

        .search-nav-btn:disabled {
            color: #666;
            cursor: not-allowed;
        }

        .search-counter {
            font-size: 11px;
            color: #ccc;
            min-width: 30px;
            text-align: center;
        }

        /* Search highlight styles */
        @keyframes flash-highlight {
            0% {
                stroke: #ffff00 !important;
                stroke-width: 6px !important;
                opacity: 1 !important;
                filter: drop-shadow(0 0 15px #ffff00) brightness(1.5);
            }
            50% {
                stroke: #ff4500 !important;
                stroke-width: 8px !important;
                opacity: 1 !important;
                filter: drop-shadow(0 0 20px #ff4500) brightness(2);
            }
            100% {
                stroke: #ffff00 !important;
                stroke-width: 6px !important;
                opacity: 1 !important;
                filter: drop-shadow(0 0 15px #ffff00) brightness(1.5);
            }
        }

        .search-flash .node {
            animation: flash-highlight 1.2s ease-in-out infinite;
        }

        .search-highlight .node {
            stroke: #00ff00 !important;
            stroke-width: 8px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 25px #00ff00) brightness(3) saturate(2) !important;
            fill: #ffffff !important;
        }

        /* Make current search result VERY obvious */
        .search-current .node {
            stroke: #ff0000 !important;
            stroke-width: 12px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 30px #ff0000) brightness(3) saturate(3) !important;
            fill: #ffffff !important;
        }

        /* Time playhead styles */
        .time-playhead {
            background: linear-gradient(90deg, #4a90e2 0%, #27ae60 50%, #9b59b6 100%);
            height: 8px;
            border-radius: 4px;
        }

        .time-display {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            margin-top: 5px;
            color: #4a90e2;
        }

        /* Legend Icon */
        #legend-icon {
            position: fixed;
            bottom: 15px;
            right: 15px;
            z-index: 1001;
            width: 40px;
            height: 40px;
            background: rgba(20, 20, 20, 0.9);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            border: 1px solid #333;
        }

        #legend-icon:hover {
            background: rgba(30, 30, 30, 0.95);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transform: scale(1.05);
        }

        #legend-icon svg {
            width: 18px;
            height: 18px;
            fill: #fff;
            transition: fill 0.2s ease;
        }

        #legend-icon:hover svg {
            fill: #4a90e2;
        }

        /* Legend Panel */
        .legend {
            position: fixed;
            bottom: 70px;
            right: 10px;
            z-index: 1000;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            max-width: calc(50vw - 15px);
            box-sizing: border-box;
            transform: translateY(100%);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid #333;
        }

        .legend.show {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }

        .legend h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        /* Slim Playback Bar */
        #playback-bar {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            background: rgba(20, 20, 20, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #playback-bar .controls-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #playback-bar .playback-btn {
            width: 24px;
            height: 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        #playback-bar .playback-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #playback-bar .playback-btn svg {
            width: 14px;
            height: 14px;
            fill: #fff;
        }

        #playback-bar .timeline-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }

        #playback-bar .timeline {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        #playback-bar .timeline::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
        }

        #playback-bar .time-display {
            font-size: 11px;
            color: #ccc;
            min-width: 60px;
            text-align: center;
        }

        #playback-bar .settings-btn {
            width: 24px;
            height: 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        #playback-bar .settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #playback-bar .settings-btn svg {
            width: 14px;
            height: 14px;
            fill: #ccc;
        }

        .playback-settings-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            display: none;
        }

        .playback-settings-dropdown.show {
            display: block;
        }

        .playback-settings-dropdown label {
            display: block;
            color: #fff;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .playback-settings-dropdown input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-bottom: 8px;
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #playback-bar {
                top: 10px;
                padding: 8px 12px;
                gap: 8px;
                max-width: calc(100vw - 120px); /* Leave space for control icons (60px each side) */
                left: 60px; /* Offset from left to avoid control icon */
                transform: translateX(0); /* Remove centering transform */
            }

            #playback-bar .timeline-container {
                min-width: 100px;
                flex: 1; /* Allow timeline to shrink/grow as needed */
            }

            #playback-bar .time-display {
                min-width: 60px;
                font-size: 9px;
            }

            #playback-bar .settings-btn {
                width: 28px;
                height: 28px;
            }

            #playback-bar .settings-btn svg {
                width: 16px;
                height: 16px;
            }

            #playback-bar .playback-btn {
                width: 28px;
                height: 28px;
            }

            #playback-bar .playback-btn svg {
                width: 16px;
                height: 16px;
            }

            #controls-icon {
                top: 10px;
                left: 10px;
                width: 44px;
                height: 44px;
            }

            #legend-icon {
                bottom: 10px;
                right: 10px;
                width: 44px;
                height: 44px;
            }

            .controls {
                position: fixed;
                top: 65px;
                left: 5px;
                right: 5px;
                width: auto;
                max-width: none;
                padding: 12px;
                background: rgba(20, 20, 20, 0.95);
                border: 1px solid #333;
            }

            .legend {
                position: fixed;
                bottom: 65px;
                right: 5px;
                left: 5px;
                max-width: none;
                padding: 10px;
                background: rgba(20, 20, 20, 0.95);
                border: 1px solid #333;
            }

            /* Mobile popup card optimization */
            .popup-card {
                position: fixed;
                top: auto;
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                max-height: 50vh; /* Only take up half the screen height */
                width: auto;
                border-radius: 12px 12px 0 0; /* Rounded top corners only */
                overflow-y: auto;
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            }
        }


        /* Time axis styles */
        .time-axis {
            stroke: #444;
            stroke-width: 1px;
        }

        .time-label {
            fill: #888;
            font-size: 24px;
            text-anchor: middle;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 12px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border: 1px solid #333;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="controls-icon" onclick="toggleControls()">
            <svg viewBox="0 0 24 24">
                <path d="M7,5H21V7H7V5M7,13V11H21V13H7M4,4.5A1.5,1.5 0 0,1 5.5,6A1.5,1.5 0 0,1 4,7.5A1.5,1.5 0 0,1 2.5,6A1.5,1.5 0 0,1 4,4.5M4,10.5A1.5,1.5 0 0,1 5.5,12A1.5,1.5 0 0,1 4,13.5A1.5,1.5 0 0,1 2.5,12A1.5,1.5 0 0,1 4,10.5M7,19V17H21V19H7M4,16.5A1.5,1.5 0 0,1 5.5,18A1.5,1.5 0 0,1 4,19.5A1.5,1.5 0 0,1 2.5,18A1.5,1.5 0 0,1 4,16.5Z"/>
            </svg>
        </div>

        <svg id="visualization"></svg>

        <div class="controls">

            <div class="control-group">
                <label>Search Teachers</label>
                <div class="search-container">
                    <input type="text" id="search" placeholder="Search for a teacher...">
                    <div class="search-navigation" id="search-navigation" style="display: none;">
                        <button id="search-prev" class="search-nav-btn" onclick="previousSearchResult()">‹</button>
                        <span id="search-counter" class="search-counter">0 / 0</span>
                        <button id="search-next" class="search-nav-btn" onclick="nextSearchResult()">›</button>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>Layout Force</label>
                <input type="range" id="forceStrength" min="0" max="100" value="30">
            </div>

            <div class="control-group">
                <label>Filter by Transmission</label>
                <button onclick="filterTransmission('all')" class="active">All</button>
                <button onclick="filterTransmission('Mind to Mind')">Mind</button>
                <button onclick="filterTransmission('Symbolic')">Symbolic</button>
                <button onclick="filterTransmission('Aural')">Aural</button>
            </div>

            <div class="control-group">
                <label>Filter by Lineage</label>
                <button onclick="filterLineage('all')" class="active">All</button>
                <button onclick="filterLineage('Vairocana')">Vairocana</button>
                <button onclick="filterLineage('Vimalamitra')">Vimalamitra</button>
                <button onclick="filterLineage('Padmasambhava')">Padmasambhava</button>
            </div>

            <div class="control-group">
                <label>Layout Mode</label>
                <button onclick="setLayoutMode('circular')" class="active" id="circular-btn">Circular</button>
                <button onclick="setLayoutMode('linear')" id="linear-btn">Linear</button>
            </div>

            <div class="control-group">
                <label>Language</label>
                <select id="language-select" onchange="setLanguage(this.value)">
                    <option value="english">English</option>
                    <option value="tibetan">Tibetan</option>
                    <option value="chinese">Chinese</option>
                </select>
            </div>
        </div>

        <!-- Slim Playback Bar -->
        <div id="playback-bar">
            <div class="controls-group">
                <button class="playback-btn" onclick="resetTime()" title="Reset">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/>
                    </svg>
                </button>
                <button class="playback-btn" onclick="togglePlayPause()" id="play-btn" title="Play">
                    <svg viewBox="0 0 24 24">
                        <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                    </svg>
                </button>
                <button class="playback-btn" onclick="togglePlayPause()" id="pause-btn" title="Pause" style="display: none;">
                    <svg viewBox="0 0 24 24">
                        <path d="M14,19H18V5H14M6,19H10V5H6V19Z"/>
                    </svg>
                </button>
            </div>

            <div class="timeline-container">
                <input type="range" id="timeSlider" min="0" max="100" value="100" class="timeline">
                <div class="time-display" id="timeDisplay">Year: 2000</div>
            </div>

            <button class="settings-btn" onclick="togglePlaybackSettings()" title="Settings">
                <svg viewBox="0 0 24 24">
                    <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                </svg>
            </button>

            <div class="playback-settings-dropdown" id="playback-settings">
                <label>Animation Speed</label>
                <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
            </div>
        </div>

        <div id="legend-icon" onclick="toggleLegend()">
            <svg viewBox="0 0 24 24">
                <path d="M19,3H5C3.9,3 3,3.9 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.9 20.1,3 19,3M5,19V5H19V19H5M17,17H7V15H17V17M17,13H7V11H17V13M17,9H7V7H17V9Z"/>
            </svg>
        </div>

        <div class="legend">
            <h4>Transmission Modes</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                Mind-to-Mind
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9b59b6;"></div>
                Symbolic
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #27ae60;"></div>
                Aural
            </div>

            <h4 style="margin-top: 15px;">Relationship Types</h4>
            <div class="legend-item">
                <span style="margin-right: 8px;">━━━</span> Teaching
            </div>
            <div class="legend-item">
                <span style="margin-right: 8px;">┅┅┅</span> Incarnation
            </div>
            <div class="legend-item">
                <span style="margin-right: 8px;">╌╌╌</span> Family
            </div>
            <div class="legend-item">
                <span style="margin-right: 8px;">···</span> Emanation
            </div>
        </div>

        <!-- Popup card for node details -->
        <div id="popup-card" class="popup-card hidden">
            <div class="popup-header">
                <h3 id="popup-title"></h3>
                <button class="popup-close" onclick="closePopup()">&times;</button>
            </div>
            <div class="popup-body">
                <div id="popup-images" class="popup-images"></div>
                <div id="popup-img-subtext" class="popup-img-subtext"></div>
                <div id="popup-tibetan"></div>
                <div id="popup-dates"></div>
                <div id="popup-description"></div>
                <div id="popup-links" class="popup-links"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let simulation;
        let svg;
        let nodes = [];
        let links = [];
        let nodeElements;
        let linkElements;
        let tooltip;
        let currentTime = 100; // Current time position (0-100)
        let isPlaying = false;
        let playInterval;
        let animationSpeed = 1;
        let zoomBehavior; // Global zoom behavior reference

        // Filters
        let currentFilter = 'all';
        let currentLineageFilter = 'all';
        let layoutMode = 'circular'; // 'linear' or 'circular'
        let currentLanguage = 'english'; // 'english', 'tibetan', 'chinese'
        let densitySensitivity = 1.0;
        let tracebackActive = false;
        let tracedNodes = new Set();
        let tracedLinks = new Set();
        let tracebackTimeouts = []; // Track animation timeouts

        // Popup variables
        let currentPopupNode = null;
        let currentPopupData = null;
        let imageManifest = null;
        let manifestLoadPromise = null;

        // Drag tracking for click vs drag detection
        let dragStart = { x: 0, y: 0 };
        let isDragging = false;

        // Dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = Math.min(width, height) * 0.4;
        const margin = { top: 50, right: 50, bottom: 100, left: 50 };

        // Initialize visualization
        function init() {
            // Setup SVG
            svg = d3.select('#visualization')
                .attr('width', width)
                .attr('height', height);

            // Create tooltip
            tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Setup zoom
            zoomBehavior = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    svg.select('.main-group').attr('transform', event.transform);
                    updateYAxisPosition(event.transform);
                });

            svg.call(zoomBehavior);

            // Add click-away functionality to clear traceback
            svg.on('click', function(event) {
                if (event.target === this) {
                    clearTraceback();
                }
            });

            // Create main group for all elements
            svg.append('g').attr('class', 'main-group');

            // Setup event listeners
            setupEventListeners();

            // Load data
            loadData();
        }

        function setupEventListeners() {
            // Time slider
            document.getElementById('timeSlider').addEventListener('input', function() {
                currentTime = parseFloat(this.value);
                updateTimeDisplay();
                updateVisualization();
            });

            // Speed slider
            document.getElementById('speedSlider').addEventListener('input', function() {
                animationSpeed = parseFloat(this.value);
            });

            // Force strength slider
            document.getElementById('forceStrength').addEventListener('input', function() {
                if (simulation) {
                    const strength = -parseInt(this.value);
                    simulation.force('charge').strength(strength);
                    simulation.alpha(0.3).restart();
                }
            });
        }

        async function loadData() {
            try {
                const response = await fetch('./data/dzogchen_lineage.csv');
                const csvText = await response.text();

                const parsedData = parseCSV(csvText);
                processData(parsedData);
                createVisualization();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));

            return lines.slice(1).map(line => {
                const values = parseCSVLine(line);
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                return row;
            });
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim().replace(/"/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim().replace(/"/g, ''));
            return values;
        }

        function processData(data) {
            // Process nodes
            nodes = data.map(d => {
                const positionDate = parseFloat(d.Position_Date) || 0;
                return {
                    id: d.Name_English,
                    name: d.Name_English,
                    transmission: d.Transmission_Mode || 'Aural',
                    lineage: d.Lineage || 'All lineages',
                    position: positionDate,
                    teachers: (d.Received_Teachings_From || '').split(';').filter(t => t.trim()),
                    students: (d.Gave_Teachings_To || '').split(';').filter(s => s.trim()),
                    incarnationOf: (d.Incarnation_Of || '').split(';').filter(i => i.trim()),
                    familyFrom: (d.Family_Received_From || '').split(';').filter(f => f.trim()),
                    emanatedAs: (d['Eminated as'] || '').split(';').filter(e => e.trim()),
                    // Additional popup fields
                    wylie: d.Name_Wylie_Tibetan || '',
                    tibetan: d.Name_Tibetan || '',
                    chinese: d.Name_Chinese || '',
                    dates: d.Dates || '',
                    description: d.Description_English || '',
                    descriptionTibetan: d.Description_Tibetan || '',
                    descriptionChinese: d.Description_Chinese || '',
                    // New fields for image subtext and links
                    imgSubtext: d.Img_Subtext || '',
                    linksNames: d.Links_Names || '',
                    linksUrls: d.Links_URLs || ''
                };
            });

            // Process links
            links = [];
            nodes.forEach(node => {
                // Teaching relationships
                node.teachers.forEach(teacherName => {
                    const teacher = nodes.find(n => n.id === teacherName.trim());
                    if (teacher) {
                        links.push({
                            source: teacher.id,
                            target: node.id,
                            type: 'teaching'
                        });
                    }
                });

                // Incarnation relationships
                node.incarnationOf.forEach(prevName => {
                    const prev = nodes.find(n => n.id === prevName.trim());
                    if (prev) {
                        links.push({
                            source: prev.id,
                            target: node.id,
                            type: 'incarnation'
                        });
                    }
                });

                // Family relationships
                node.familyFrom.forEach(familyName => {
                    const family = nodes.find(n => n.id === familyName.trim());
                    if (family) {
                        links.push({
                            source: family.id,
                            target: node.id,
                            type: 'family'
                        });
                    }
                });

                // Emanation relationships
                node.emanatedAs.forEach(emanationName => {
                    const emanation = nodes.find(n => n.id === emanationName.trim());
                    if (emanation) {
                        links.push({
                            source: node.id,
                            target: emanation.id,
                            type: 'emanation'
                        });
                    }
                });
            });

            // Debug: Check transmission types
            const transmissionTypes = [...new Set(nodes.map(n => n.transmission))];
            console.log('Transmission types found:', transmissionTypes);

            // Debug: Count by transmission
            const transmissionCounts = {};
            nodes.forEach(n => {
                transmissionCounts[n.transmission] = (transmissionCounts[n.transmission] || 0) + 1;
            });
            console.log('Transmission counts:', transmissionCounts);

            // Debug: Check first few Mind to Mind nodes
            const mindToMindNodes = nodes.filter(n => n.transmission === 'Mind to Mind');
            console.log(`Found ${mindToMindNodes.length} Mind to Mind nodes:`, mindToMindNodes.slice(0, 3));

            console.log(`Loaded ${nodes.length} nodes and ${links.length} links`);
        }

        // Create radial positioning function for circular mode
        function createRadialTimeScale(nodes) {
            if (nodes.length === 0) return (pos) => 20; // Minimum radius

            const timeExtent = d3.extent(nodes, d => d.position);
            const minTime = timeExtent[0];
            const maxTime = timeExtent[1];

            // Define radius range - early times close to center, later times further out
            const minRadius = 20;  // Minimum distance from center for earliest nodes
            const maxRadius = Math.min(width, height) * 0.4; // Maximum radius (40% of viewport)

            // Create a scale that maps time to radius
            // Using square root scale to give more space to later periods
            const radiusScale = d3.scaleSqrt()
                .domain([minTime, maxTime])
                .range([minRadius, maxRadius]);

            return radiusScale;
        }

        // Calculate angular position for nodes at the same time period
        function calculateAngularPosition(node, nodesAtSameTime, index) {
            // Distribute nodes evenly around the circle
            const angleStep = (2 * Math.PI) / Math.max(nodesAtSameTime.length, 1);

            // Use lineage information to group nodes
            const lineageGroups = {
                'Vairocana': 0,
                'Vimalamitra': 1,
                'Padmasambhava': 2,
                'All lineages': 1.5  // Place "All lineages" between Vimalamitra and Padmasambhava
            };

            // Get base angle based on lineage
            let baseAngle = 0;
            if (lineageGroups.hasOwnProperty(node.lineage)) {
                baseAngle = (lineageGroups[node.lineage] * 2 * Math.PI) / 3;
            } else {
                // For unknown lineages, distribute evenly
                baseAngle = (index * 2 * Math.PI) / Math.max(nodesAtSameTime.length, 1);
            }

            // Add small offset for nodes within the same lineage
            const offsetAngle = (index * angleStep * 0.3); // Smaller clustering within lineage

            return baseAngle + offsetAngle;
        }

        // Language-aware display functions
        function getDisplayName(node, language) {
            language = language || currentLanguage;
            switch (language) {
                case 'tibetan':
                    return node.tibetan || node.wylie || node.name;
                case 'chinese':
                    return node.chinese || node.name;
                case 'english':
                default:
                    return node.name;
            }
        }

        function getDisplayDescription(node, language) {
            language = language || currentLanguage;
            switch (language) {
                case 'tibetan':
                    return node.descriptionTibetan || node.description;
                case 'chinese':
                    return node.descriptionChinese || node.description;
                case 'english':
                default:
                    return node.description;
            }
        }

        function getCurrentLanguageFont() {
            switch (currentLanguage) {
                case 'tibetan':
                    return "'Noto Sans Tibetan', sans-serif";
                case 'chinese':
                    return "'Noto Sans SC', sans-serif";
                case 'english':
                default:
                    return "'Arial', sans-serif";
            }
        }

        // Create normalized time-based Y-scale for optimal vertical spacing
        function createNormalizedTimeScale(nodes) {
            // Sort nodes by time position
            const sortedNodes = [...nodes].sort((a, b) => a.position - b.position);

            if (sortedNodes.length === 0) return (pos) => margin.top;

            // Calculate time gaps between consecutive nodes
            const gaps = [];
            for (let i = 1; i < sortedNodes.length; i++) {
                const gap = sortedNodes[i].position - sortedNodes[i-1].position;
                gaps.push({
                    startTime: sortedNodes[i-1].position,
                    endTime: sortedNodes[i].position,
                    gap: gap,
                    startNode: sortedNodes[i-1],
                    endNode: sortedNodes[i]
                });
            }

            // Define minimum spacing between nodes (pixels)
            const minNodeSpacing = 15 * densitySensitivity;
            const maxGapSpacing = 40 * densitySensitivity;

            // Assign Y positions based on normalized spacing
            const yPositions = new Map();
            let currentY = margin.top;

            // Set first node position
            yPositions.set(sortedNodes[0].position, currentY);
            currentY += minNodeSpacing;

            // Calculate spacing for each gap
            gaps.forEach(gapInfo => {
                const { gap, endNode } = gapInfo;

                // Determine spacing based on time gap
                let spacing;
                if (gap <= 5) {
                    spacing = minNodeSpacing;
                } else if (gap <= 25) {
                    spacing = minNodeSpacing * 1.2;
                } else if (gap <= 50) {
                    spacing = minNodeSpacing * 1.5;
                } else if (gap <= 100) {
                    spacing = minNodeSpacing * 2;
                } else {
                    spacing = Math.min(maxGapSpacing, minNodeSpacing * 2.5);
                }

                yPositions.set(endNode.position, currentY);
                currentY += spacing;
            });

            // Constrain total height to reasonable viewport size
            const maxAllowedHeight = height * 3;
            if (currentY > maxAllowedHeight) {
                const scaleFactor = maxAllowedHeight / currentY;
                yPositions.forEach((y, position) => {
                    yPositions.set(position, margin.top + (y - margin.top) * scaleFactor);
                });
                currentY = maxAllowedHeight;
            }

            // Create interpolation function
            const yScale = (position) => {
                let beforeNode = null;
                let afterNode = null;

                for (let i = 0; i < sortedNodes.length; i++) {
                    if (sortedNodes[i].position <= position) {
                        beforeNode = sortedNodes[i];
                    }
                    if (sortedNodes[i].position >= position && !afterNode) {
                        afterNode = sortedNodes[i];
                        break;
                    }
                }

                if (!beforeNode) return yPositions.get(afterNode.position);
                if (!afterNode) return yPositions.get(beforeNode.position);
                if (beforeNode === afterNode) return yPositions.get(beforeNode.position);

                const beforeY = yPositions.get(beforeNode.position);
                const afterY = yPositions.get(afterNode.position);
                const timeDiff = afterNode.position - beforeNode.position;
                const progress = (position - beforeNode.position) / timeDiff;

                return beforeY + (afterY - beforeY) * progress;
            };

            // Store info for axis creation
            yScale.nodePositions = yPositions;
            yScale.sortedNodes = sortedNodes;
            yScale.totalHeight = currentY;

            return yScale;
        }

        function updateYAxisPosition(transform) {
            if (layoutMode !== 'linear') return;

            // Calculate where to position the axis so it appears with enough space for text labels
            // We need to invert the transform to find where screen coordinates map to in content space
            const screenLeftInContentSpace = -transform.x / transform.k;
            // Ensure minimum 100px of screen space, accounting for zoom level properly
            const minScreenDistance = Math.max(100, 100 * transform.k); // More space when zoomed in
            const axisX = screenLeftInContentSpace + (minScreenDistance / transform.k);

            const timeAxis = svg.select('.time-axis');
            if (!timeAxis.node()) return;

            // Update background rectangle
            timeAxis.select('.axis-background')
                .attr('x', axisX - 80)
                .attr('width', 80);

            // Update main axis line
            timeAxis.select('line')
                .attr('x1', axisX)
                .attr('x2', axisX);

            // Update century tick marks (x1: -30, x2: -15)
            timeAxis.selectAll('.time-tick line[stroke="#888"]')
                .attr('x1', axisX - 10)  // was margin.left - 30, now axisX - 10
                .attr('x2', axisX + 5);   // was margin.left - 15, now axisX + 5

            // Update half-century tick marks (x1: -25, x2: -15)
            timeAxis.selectAll('.time-tick line[stroke="#555"]')
                .attr('x1', axisX - 5)   // was margin.left - 25, now axisX - 5
                .attr('x2', axisX + 5);   // was margin.left - 15, now axisX + 5

            // Update tick labels - position them with more space from edge
            timeAxis.selectAll('.time-tick text')
                .attr('x', axisX - 10)    // 10px to the left of the axis line
                .style('text-anchor', 'end');  // Right-align text to axis

            // Update node circles
            timeAxis.selectAll('.time-tick circle')
                .attr('cx', axisX);       // was margin.left - 20, now axisX
        }

        function createNormalizedTimeAxis(container, yScale) {
            const timeAxis = container.append('g')
                .attr('class', 'time-axis')
                .style('display', layoutMode === 'linear' ? 'block' : 'none');

            const sortedNodes = yScale.sortedNodes;
            const nodePositions = yScale.nodePositions;

            // Set initial axis position with enough space for labels
            const initialAxisX = margin.left + 20;  // Move further from left edge

            // Add background rectangle for visual padding
            timeAxis.append('rect')
                .attr('class', 'axis-background')
                .attr('x', initialAxisX - 80)
                .attr('y', margin.top)
                .attr('width', 80)
                .attr('height', yScale.totalHeight - margin.top)
                .attr('fill', 'rgba(10, 10, 10, 0.9)')
                .attr('stroke', 'none');

            // Add main axis line
            timeAxis.append('line')
                .attr('x1', initialAxisX)
                .attr('x2', initialAxisX)
                .attr('y1', margin.top)
                .attr('y2', yScale.totalHeight)
                .attr('stroke', '#444')
                .attr('stroke-width', 2);

            // Create time markers
            const timeMarkers = [];
            const timeExtent = d3.extent(sortedNodes, d => d.position);

            // Add century markers
            for (let year = Math.floor(timeExtent[0] / 100) * 100; year <= Math.ceil(timeExtent[1] / 100) * 100; year += 100) {
                if (year >= timeExtent[0] && year <= timeExtent[1]) {
                    timeMarkers.push({ year: year, type: 'century' });
                }
            }

            // Add 50-year markers
            for (let year = Math.floor(timeExtent[0] / 50) * 50; year <= Math.ceil(timeExtent[1] / 50) * 50; year += 50) {
                if (year >= timeExtent[0] && year <= timeExtent[1] && year % 100 !== 0) {
                    timeMarkers.push({ year: year, type: 'half-century' });
                }
            }

            // Add node markers
            sortedNodes.forEach((node, i) => {
                if (i % 5 === 0) {
                    timeMarkers.push({ year: node.position, type: 'node', node: node });
                }
            });

            timeMarkers.forEach(marker => {
                const y = yScale(marker.year);
                const g = timeAxis.append('g').attr('class', 'time-tick');

                if (marker.type === 'century') {
                    g.append('line')
                        .attr('x1', initialAxisX - 10)
                        .attr('x2', initialAxisX + 5)
                        .attr('y1', y)
                        .attr('y2', y)
                        .attr('stroke', '#888')
                        .attr('stroke-width', 2);

                    g.append('text')
                        .attr('x', initialAxisX - 10)
                        .attr('y', y + 4)
                        .attr('class', 'time-label')
                        .style('fill', '#aaa')
                        .style('text-anchor', 'end')  // Right-align text to axis
                        .text(marker.year > 0 ? `${marker.year} CE` : `${Math.abs(marker.year)} BCE`);

                } else if (marker.type === 'half-century') {
                    g.append('line')
                        .attr('x1', initialAxisX - 5)
                        .attr('x2', initialAxisX + 5)
                        .attr('y1', y)
                        .attr('y2', y)
                        .attr('stroke', '#555')
                        .attr('stroke-width', 1);

                } else if (marker.type === 'node') {
                    g.append('circle')
                        .attr('cx', initialAxisX)
                        .attr('cy', y)
                        .attr('r', 2)
                        .attr('fill', '#4a90e2')
                        .attr('opacity', 0.6);
                }
            });
        }

        function createVisualization() {
            const mainGroup = svg.select('.main-group');

            // Create time axis for linear mode (conditional)
            if (layoutMode === 'linear') {
                const yScale = createNormalizedTimeScale(nodes);
                createNormalizedTimeAxis(mainGroup, yScale);
            }

            // Create empty selections that will be populated by update()
            linkElements = mainGroup.append('g')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .selectAll('line');

            nodeElements = mainGroup.append('g')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .selectAll('circle');

            // Create force simulation (empty initially)
            createTemporalSimulation();

            // Initial update
            updateTimeDisplay();
            updateVisualization();

            // Set initial zoom level after visualization is created
            setTimeout(() => {
                // Calculate translation to keep content centered when scaling
                const scale = 0.5;
                const centerX = width / 2;
                const centerY = height / 2;
                const translateX = centerX - (centerX * scale);
                const translateY = centerY - (centerY * scale);

                const initialTransform = d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale);

                svg.transition()
                    .duration(1000)
                    .call(zoomBehavior.transform, initialTransform);
                console.log('Applied initial zoom level: 0.5x with centered transform');
            }, 200); // Small delay to ensure everything is rendered
        }

        function createTemporalSimulation() {
            if (layoutMode === 'circular') {
                // Circular mode: radial time-based positioning
                const radiusScale = createRadialTimeScale(nodes);

                simulation = d3.forceSimulation()
                    .force('charge', d3.forceManyBody().strength(-80))
                    .force('link', d3.forceLink().id(d => d.id).distance(40).strength(0.2))
                    .force('radial', d3.forceRadial(d => radiusScale(d.position), centerX, centerY).strength(0.8))
                    .force('collision', d3.forceCollide().radius(d => {
                        const connections = d.teachers.length + d.students.length;
                        return Math.max(6, Math.min(14, connections * 1.5 + 6));
                    }))
                    .on('tick', tick);
            } else {
                // Linear mode: time-based Y positioning with moderate horizontal spread
                const yScale = createNormalizedTimeScale(nodes);
                simulation = d3.forceSimulation()
                    .force('charge', d3.forceManyBody().strength(-120)) // Moderate repulsion
                    .force('link', d3.forceLink().id(d => d.id).distance(50).strength(0.3))
                    .force('x', d3.forceX(centerX).strength(0.05)) // Gentle X centering
                    .force('y', d3.forceY(d => yScale(d.position)).strength(0.9))
                    .force('collision', d3.forceCollide().radius(d => {
                        const connections = d.teachers.length + d.students.length;
                        return Math.max(7, Math.min(15, connections * 1.8 + 7)); // Moderate collision radius
                    }))
                    .on('tick', tick);
            }
        }

        function tick() {
            // Update link positions
            linkElements
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            // Update node positions
            nodeElements
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
        }

        function updateVisualization() {
            const maxPosition = Math.max(...nodes.map(n => n.position));
            const minPosition = Math.min(...nodes.map(n => n.position));
            const timeThreshold = minPosition + (currentTime / 100) * (maxPosition - minPosition);

            // Filter nodes that exist at current time and match filters
            const visibleNodes = nodes.filter(d => {
                const existsAtTime = d.position <= timeThreshold;
                const transmissionMatch = currentFilter === 'all' || d.transmission === currentFilter;
                const lineageMatch = currentLineageFilter === 'all' ||
                                   d.lineage === currentLineageFilter ||
                                   d.lineage === 'All lineages' ||
                                   d.lineage.includes(currentLineageFilter);


                return existsAtTime && transmissionMatch && lineageMatch;
            });

            // Filter links where both nodes are visible
            const visibleNodeIds = new Set(visibleNodes.map(d => d.id));
            const visibleLinks = links.filter(d =>
                visibleNodeIds.has(d.source.id || d.source) &&
                visibleNodeIds.has(d.target.id || d.target)
            );

            // Update the simulation - CRITICAL: preserve old node positions
            updateSimulation(visibleNodes, visibleLinks);
        }

        function updateSimulation(visibleNodes, visibleLinks) {
            // Make a shallow copy to protect against mutation, while
            // recycling old nodes to preserve position and velocity.
            const old = new Map(nodeElements.data().map(d => [d.id, d]));
            const updatedNodes = visibleNodes.map(d => {
                const oldNode = old.get(d.id);
                if (oldNode) {
                    // Preserve existing node with its position
                    return {...oldNode, ...d};
                } else {
                    // New node - set good initial position to prevent fly-in effect
                    const newNode = {...d};
                    if (layoutMode === 'circular') {
                        // For circular mode, calculate proper radial position
                        const radiusScale = createRadialTimeScale(nodes);
                        const radius = radiusScale(d.position);

                        // Find other nodes at similar time periods for angular distribution
                        const timeWindow = 50; // Nodes within 50 position units are considered "same time"
                        const nodesAtSameTime = nodes.filter(n =>
                            Math.abs(n.position - d.position) <= timeWindow
                        );
                        const nodeIndex = nodesAtSameTime.findIndex(n => n.id === d.id);

                        // Calculate angular position
                        const angle = calculateAngularPosition(d, nodesAtSameTime, nodeIndex);

                        // Set initial position using polar coordinates
                        newNode.x = centerX + radius * Math.cos(angle);
                        newNode.y = centerY + radius * Math.sin(angle);
                    } else {
                        // For linear mode, start at appropriate Y position with wider X spread
                        const yScale = createNormalizedTimeScale(nodes);
                        newNode.x = centerX + (Math.random() - 0.5) * 200; // Much wider initial spread
                        newNode.y = yScale(d.position);
                    }
                    return newNode;
                }
            });
            const updatedLinks = visibleLinks.map(d => ({...d}));

            // Update nodes with enter/exit pattern
            nodeElements = nodeElements
                .data(updatedNodes, d => d.id)
                .join(enter => enter.append('circle')
                    .attr('r', d => {
                        // Make Samantabhadra/Samantabhadri larger (primordial source)
                        if (d.name.toLowerCase().includes('samantabhadra') ||
                            d.name.toLowerCase().includes('samantabhadri')) {
                            return 16; // Larger for the primordial Buddha
                        }
                        const connections = d.teachers.length + d.students.length;
                        return Math.max(4, Math.min(12, connections * 1.2 + 4));
                    })
                    .attr('class', d => `node ${d.transmission.toLowerCase().replace(/\s+/g, '-')}`)
                    .call(node => node.append('title').text(d => getDisplayName(d)))
                );

            // CRITICAL: Apply drag handlers and event listeners to ALL nodes (new and existing)
            nodeElements
                .call(drag(simulation))
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip);

            // Update links with enter/exit pattern
            linkElements = linkElements
                .data(updatedLinks, d => [d.source.id || d.source, d.target.id || d.target])
                .join('line')
                .attr('class', d => `link ${d.type}`);

            // Update simulation forces
            simulation.nodes(updatedNodes);
            simulation.force('link').links(updatedLinks);
            simulation.alpha(1).restart();

            // Reapply traceback highlighting if active
            if (tracebackActive) {
                applyTracebackHighlighting();
            }
        }

        // Add drag functionality
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;

                // Track initial position for click vs drag detection
                dragStart = { x: event.x, y: event.y };
                isDragging = false;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;

                // Check if we've moved enough to consider this a drag
                const distance = Math.sqrt(
                    Math.pow(event.x - dragStart.x, 2) +
                    Math.pow(event.y - dragStart.y, 2)
                );
                if (distance > 5) {
                    isDragging = true;
                }
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;

                // If no significant dragging occurred, treat as a click
                if (!isDragging) {
                    console.log('Node clicked (not dragged) - triggering traceback and popup for:', d.name);

                    // Show popup with node information
                    showPopup(d, event);

                    // Trigger traceback animation
                    activateTraceback(d);
                }
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }

        function updateTimeDisplay() {
            const maxPosition = Math.max(...nodes.map(n => n.position));
            const minPosition = Math.min(...nodes.map(n => n.position));
            const currentYear = Math.round(minPosition + (currentTime / 100) * (maxPosition - minPosition));
            document.getElementById('timeDisplay').textContent = `Year: ${currentYear}`;
        }

        function showTooltip(event, d) {
            tooltip.transition().duration(200).style('opacity', .9);
            tooltip.html(`
                <strong>${getDisplayName(d)}</strong><br/>
                Transmission: ${d.transmission}<br/>
                Lineage: ${d.lineage}<br/>
                Time Position: ${d.position}<br/>
                Teachers: ${d.teachers.length}<br/>
                Students: ${d.students.length}
            `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 28) + 'px');
        }

        function hideTooltip() {
            tooltip.transition().duration(500).style('opacity', 0);
        }

        // Control functions
        function togglePlayPause() {
            if (isPlaying) {
                pauseTime();
            } else {
                playTime();
            }
        }

        function playTime() {
            if (!isPlaying) {
                isPlaying = true;
                // Show pause button, hide play button
                document.getElementById('play-btn').style.display = 'none';
                document.getElementById('pause-btn').style.display = 'flex';

                playInterval = setInterval(() => {
                    currentTime += animationSpeed;
                    if (currentTime > 100) {
                        currentTime = 100;
                        pauseTime();
                    }
                    document.getElementById('timeSlider').value = currentTime;
                    updateTimeDisplay();
                    updateVisualization();
                }, 100);
            }
        }

        function pauseTime() {
            isPlaying = false;
            if (playInterval) {
                clearInterval(playInterval);
            }
            // Show play button, hide pause button
            document.getElementById('play-btn').style.display = 'flex';
            document.getElementById('pause-btn').style.display = 'none';
        }

        function resetTime() {
            pauseTime();
            currentTime = 0;
            document.getElementById('timeSlider').value = currentTime;
            updateTimeDisplay();
            updateVisualization();
        }

        function filterTransmission(mode) {
            currentFilter = mode;

            // Update button states
            document.querySelectorAll('.controls .control-group:nth-child(3) button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            updateVisualization();
        }

        function filterLineage(lineage) {
            currentLineageFilter = lineage;

            // Update button states
            document.querySelectorAll('.controls .control-group:nth-child(4) button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            updateVisualization();
        }

        function setLayoutMode(mode) {
            if (layoutMode !== mode) {
                layoutMode = mode;

                // Update button states
                document.querySelectorAll('.controls .control-group:nth-child(5) button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(mode === 'linear' ? 'linear-btn' : 'circular-btn').classList.add('active');

                // Toggle time axis visibility
                const timeAxis = svg.select('.time-axis');
                if (timeAxis.node()) {
                    timeAxis.style('display', mode === 'linear' ? 'block' : 'none');
                }

                // Recreate simulation and axis if needed
                if (mode === 'linear' && !svg.select('.time-axis').node()) {
                    // Create time axis if switching to linear for the first time
                    const mainGroup = svg.select('.main-group');
                    const yScale = createNormalizedTimeScale(nodes);
                    createNormalizedTimeAxis(mainGroup, yScale);
                }

                // Stop current simulation and create new one
                if (simulation) {
                    simulation.stop();
                }
                createTemporalSimulation();

                // Re-run current visualization update
                updateVisualization();

                // Auto-zoom to fit all nodes when switching to linear mode
                if (mode === 'linear') {
                    setTimeout(() => {
                        // Calculate translation to keep content centered when scaling
                        const scale = 0.5;
                        const centerX = width / 2;
                        const centerY = height / 2;
                        const translateX = centerX - (centerX * scale);
                        const translateY = centerY - (centerY * scale);

                        const zoomTransform = d3.zoomIdentity
                            .translate(translateX, translateY)
                            .scale(scale);

                        svg.transition()
                            .duration(1000)
                            .call(zoomBehavior.transform, zoomTransform);
                        console.log('Auto-zoomed out in linear mode to show all nodes');
                    }, 300); // Small delay to ensure layout is updated
                }

                console.log(`Layout mode switched to: ${mode}`);
            }
        }

        function setLanguage(language) {
            if (currentLanguage !== language) {
                currentLanguage = language;

                // Update dropdown selection
                const languageSelect = document.getElementById('language-select');
                if (languageSelect) {
                    languageSelect.value = language;
                }

                // Update all visible text elements
                updateLanguageDisplay();

                console.log(`Language switched to: ${language}`);
            }
        }

        function updateLanguageDisplay() {
            // Update node tooltips
            if (nodeElements) {
                nodeElements.selectAll('title').text(d => getDisplayName(d));
            }

            // Update any open popup
            if (currentPopupData) {
                updatePopupLanguage(currentPopupData);
            }

            // Update all UI language elements
            updateAllUILanguage();

            // Apply language-specific styling to body
            document.body.className = document.body.className.replace(/\b(english|tibetan|chinese)-text\b/g, '');
            document.body.classList.add(`${currentLanguage}-text`);
            document.body.style.fontFamily = getCurrentLanguageFont();
        }

        // UI Language translations
        const uiTranslations = {
            english: {
                // Control Panel Labels
                search: 'Search Teachers',
                searchPlaceholder: 'Search teachers by name...',
                filterTransmission: 'Filter by Transmission',
                filterLineage: 'Filter by Lineage',
                layoutMode: 'Layout Mode',
                language: 'Language',
                // Transmission Options
                all: 'All',
                mind: 'Mind',
                symbolic: 'Symbolic',
                aural: 'Aural',
                // Layout Options
                circular: 'Circular',
                linear: 'Linear',
                // Language Options
                englishLang: 'English',
                tibetanLang: 'Tibetan',
                chineseLang: 'Chinese',
                // Playback Controls
                animationSpeed: 'Animation Speed',
                reset: 'Reset',
                // Popup Labels
                dates: 'Dates',
                wylie: 'Wylie',
                links: 'Links'
            },
            tibetan: {
                // Control Panel Labels
                search: 'འཚོལ་ཞིབ།',
                searchPlaceholder: 'སློབ་དཔོན་གྱི་མིང་ཅན་འཚོལ་ཞིབ།',
                filterTransmission: 'སྐུ་གསུམ་གྱི་རྒྱུད་པས་དབྱེ་བ།',
                filterLineage: 'བརྒྱུད་པས་དབྱེ་བ།',
                layoutMode: 'གཞི་རྩའི་རྣམ་པ།',
                language: 'སྐད་ཡིག',
                // Transmission Options
                all: 'ཀུན།',
                mind: 'ཐུགས།',
                symbolic: 'རྟགས།',
                aural: 'སྙན།',
                // Layout Options
                circular: 'ཟླུམ་པོ།',
                linear: 'ཐིག་ལེ།',
                // Language Options
                englishLang: 'དབྱིན་ཇི།',
                tibetanLang: 'བོད་ཡིག',
                chineseLang: 'རྒྱ་ཡིག',
                // Playback Controls
                animationSpeed: 'གཡོ་སྒྱུའི་མྱུར་ཚད།',
                reset: 'བསྐྱར་སྒྲིག',
                // Popup Labels
                dates: 'ལོ་ཚིགས།',
                wylie: 'ཝའི་ལི།',
                links: 'འབྲེལ་ཐག'
            },
            chinese: {
                // Control Panel Labels
                search: '搜索老师',
                searchPlaceholder: '按姓名搜索老师...',
                filterTransmission: '按传承方式筛选',
                filterLineage: '按传承谱系筛选',
                layoutMode: '布局模式',
                language: '语言',
                // Transmission Options
                all: '全部',
                mind: '心传',
                symbolic: '符号传',
                aural: '耳传',
                // Layout Options
                circular: '圆形',
                linear: '线性',
                // Language Options
                englishLang: '英语',
                tibetanLang: '藏语',
                chineseLang: '中文',
                // Playback Controls
                animationSpeed: '动画速度',
                reset: '重置',
                // Popup Labels
                dates: '日期',
                wylie: '威利转写',
                links: '链接'
            }
        };

        function updateSearchPlaceholder() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.placeholder = uiTranslations[currentLanguage].searchPlaceholder;
            }
        }

        function updateAllUILanguage() {
            const t = uiTranslations[currentLanguage];

            // Update control panel labels using specific selectors
            const searchLabel = document.querySelector('.controls .control-group:nth-child(1) label');
            if (searchLabel) searchLabel.textContent = t.search;

            // Layout Force label stays as is (it's a technical term)

            const transmissionLabel = document.querySelector('.controls .control-group:nth-child(3) label');
            if (transmissionLabel) transmissionLabel.textContent = t.filterTransmission;

            const lineageLabel = document.querySelector('.controls .control-group:nth-child(4) label');
            if (lineageLabel) lineageLabel.textContent = t.filterLineage;

            const layoutLabel = document.querySelector('.controls .control-group:nth-child(5) label');
            if (layoutLabel) layoutLabel.textContent = t.layoutMode;

            const languageLabel = document.querySelector('.controls .control-group:nth-child(6) label');
            if (languageLabel) languageLabel.textContent = t.language;

            // Update transmission filter buttons
            const transmissionBtns = document.querySelectorAll('.controls .control-group:nth-child(3) button');
            if (transmissionBtns[0]) transmissionBtns[0].textContent = t.all;
            if (transmissionBtns[1]) transmissionBtns[1].textContent = t.mind;
            if (transmissionBtns[2]) transmissionBtns[2].textContent = t.symbolic;
            if (transmissionBtns[3]) transmissionBtns[3].textContent = t.aural;

            // Update lineage filter buttons
            const lineageBtns = document.querySelectorAll('.controls .control-group:nth-child(4) button');
            if (lineageBtns[0]) lineageBtns[0].textContent = t.all;
            // Keep lineage names as they are (proper names)

            // Update layout mode buttons
            const layoutBtns = document.querySelectorAll('.controls .control-group:nth-child(5) button');
            if (layoutBtns[0]) layoutBtns[0].textContent = t.circular;
            if (layoutBtns[1]) layoutBtns[1].textContent = t.linear;

            // Update language dropdown options
            const langSelect = document.getElementById('language-select');
            if (langSelect) {
                const options = langSelect.querySelectorAll('option');
                if (options[0]) options[0].textContent = t.englishLang;
                if (options[1]) options[1].textContent = t.tibetanLang;
                if (options[2]) options[2].textContent = t.chineseLang;
            }

            // Update playback controls
            const speedLabel = document.querySelector('.playback-settings-dropdown label');
            if (speedLabel) speedLabel.textContent = t.animationSpeed;

            // Update search placeholder
            updateSearchPlaceholder();
        }

        // Perfect traceback algorithm copied from index.html
        function findAllPathsToSource(targetNode) {
            // Build trajectory with distance information for perfect cascade (like original)
            const trajectoryNodes = new Map();
            trajectoryNodes.set(targetNode.id, { distance: 0, node: targetNode });

            // Find all ancestors - trace upward through ALL relationship types
            function findAncestors(nodeId, distance) {
                // ALL relationship types: teaching, incarnation, emanation, family
                links.forEach(link => {
                    if (link.target.id === nodeId || link.target === nodeId) {
                        const sourceId = link.source.id || link.source;
                        if (!trajectoryNodes.has(sourceId)) {
                            const ancestorNode = nodes.find(n => n.id === sourceId);
                            if (ancestorNode) {
                                console.log(`Found ${link.type} relationship: ${sourceId} -> ${nodeId} at distance ${distance + 1}`);
                                trajectoryNodes.set(sourceId, { distance: distance + 1, node: ancestorNode });
                                findAncestors(sourceId, distance + 1);
                            }
                        }
                    }
                });
            }

            // Trace upward through all relationships
            findAncestors(targetNode.id, 0);

            // Convert to arrays and include the links in the trajectory
            const trajectoryLinks = [];
            links.forEach(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;

                // Include link if both nodes are in trajectory
                if (trajectoryNodes.has(sourceId) && trajectoryNodes.has(targetId)) {
                    trajectoryLinks.push(link);
                }
            });

            return {
                nodes: Array.from(trajectoryNodes.values()).map(item => item.node),
                links: trajectoryLinks,
                trajectoryMap: trajectoryNodes // Keep distance info for perfect timing
            };
        }

        // Legacy function name for compatibility
        function findPathToSource(targetNode) {
            return findAllPathsToSource(targetNode);
        }

        function activateTraceback(clickedNode) {
            clearTraceback();
            tracebackActive = true;

            const path = findPathToSource(clickedNode);

            if (path.nodes.length === 0) {
                console.log(`No path found from ${clickedNode.name}`);
                return;
            }

            console.log(`Traceback from ${clickedNode.name} found ${path.nodes.length} nodes in path:`);
            path.nodes.forEach((node, i) => {
                console.log(`  ${i + 1}. ${node.name} (${node.transmission}) - Position: ${node.position}`);
            });

            // Auto-zoom to fit entire traceback path
            autoZoomToFitTraceback(path.nodes);

            // Animate the traceback flow step by step with clicked node ID
            animateTracebackFlow(path, clickedNode.id);
        }

        function autoZoomToFitTraceback(tracebackNodes) {
            if (tracebackNodes.length === 0 || !zoomBehavior) return;

            // Add small delay to ensure node positions are available
            setTimeout(() => {
                // Get bounding box of all traceback nodes using the node data directly
                const nodePositions = [];

                nodeElements.each(function(d) {
                    // Check if this node is in our traceback path
                    const isInTraceback = tracebackNodes.some(node => node.id === d.id);
                    if (isInTraceback && d.x !== undefined && d.y !== undefined) {
                        nodePositions.push({ x: d.x, y: d.y });
                        console.log(`Node ${d.id}: x=${d.x}, y=${d.y}`);
                    }
                });

                if (nodePositions.length === 0) {
                    console.log('No valid node positions found for auto-zoom');
                    return;
                }

                // Calculate bounding box
                const minX = Math.min(...nodePositions.map(p => p.x));
                const maxX = Math.max(...nodePositions.map(p => p.x));
                const minY = Math.min(...nodePositions.map(p => p.y));
                const maxY = Math.max(...nodePositions.map(p => p.y));

                // Add padding around the bounding box
                const padding = 100;
                const boundsWidth = maxX - minX + (padding * 2);
                const boundsHeight = maxY - minY + (padding * 2);
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Calculate scale to fit bounds in viewport
                const scaleX = width / boundsWidth;
                const scaleY = height / boundsHeight;
                const scale = Math.min(scaleX, scaleY, 2); // Cap at 2x zoom

                // Calculate translation to center the bounds
                const translateX = width / 2 - centerX * scale;
                const translateY = height / 2 - centerY * scale;

                // Apply smooth zoom transition using the global zoom behavior
                const transform = d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale);

                svg.transition()
                    .duration(1000) // 1 second smooth zoom
                    .call(zoomBehavior.transform, transform);

                console.log(`Auto-zoomed to fit ${nodePositions.length} nodes: scale=${scale.toFixed(2)}, center=(${centerX.toFixed(0)}, ${centerY.toFixed(0)})`);
            }, 100); // Small delay to ensure positions are updated
        }

        // Perfect cascade animation copied from index.html
        function animateTracebackFlow(allPaths, clickedNodeId) {
            const { trajectoryMap } = allPaths; // Use the distance-based map for perfect timing

            // First dim all elements
            nodeElements.classed('dimmed', true);
            linkElements.classed('dimmed', true);

            console.log(`Starting perfect traceback cascade for ${trajectoryMap.size} nodes`);

            // Create perfect ripple cascade effect (exactly like original)
            createRippleCascade(trajectoryMap, clickedNodeId);
        }

        function createRippleCascade(trajectoryNodes, clickedNodeId) {
            // Clear any existing ripple timeouts first
            tracebackTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            tracebackTimeouts = [];

            // Sort nodes by distance for proper cascade order (EXACTLY like original)
            const sortedNodes = Array.from(trajectoryNodes.entries())
                .sort(([,a], [,b]) => a.distance - b.distance);

            // Apply animations and highlighting with staggered timing (PERFECT original timing)
            sortedNodes.forEach(([nodeId, nodeInfo], index) => {
                const delay = index * 120; // EXACT 120ms delay from original - PERFECT timing
                const isMainNode = nodeId === clickedNodeId;

                const timeoutId = setTimeout(() => {
                    // Add this node to traced set
                    tracedNodes.add(nodeId);
                    console.log(`Cascade step ${index + 1}: Highlighting node "${nodeInfo.node.name}" at distance ${nodeInfo.distance}`);

                    // Find the node element and apply highlighting (like original)
                    nodeElements.filter(d => d.id === nodeId).each(function(d) {
                        const nodeElement = d3.select(this);

                        // Apply highlighting effects with animation (like original)
                        const brightnessFactor = isMainNode ? 1.5 : 1.2;
                        const strokeColor = isMainNode ? '#FFD700' : '#ff6b35';
                        const strokeWidth = isMainNode ? 4 : 3;

                        // Apply highlighting
                        nodeElement
                            .classed('dimmed', false)
                            .classed('traced', true)
                            .classed('target', isMainNode)
                            .transition()
                            .duration(200) // EXACT duration from original
                            .style('opacity', 1)
                            .attr('stroke', strokeColor)
                            .attr('stroke-width', strokeWidth);

                        // Add simple grow/shrink animation for the clicked node
                        if (isMainNode) {
                            const originalRadius = parseFloat(nodeElement.attr('r'));
                            const enlargedRadius = originalRadius * 1.4;
                            const finalRadius = originalRadius * 1.15; // Just slightly bigger than original

                            nodeElement
                                .transition()
                                .delay(150)
                                .duration(150)
                                .attr('r', enlargedRadius)
                                .transition()
                                .duration(150)
                                .attr('r', finalRadius);
                        }
                    });

                    // Highlight the incoming links with EXACT 50ms delay (like original)
                    const linkTimeoutId = setTimeout(() => {
                        // Check if traceback is still active before proceeding
                        if (!tracebackActive) return;

                        linkElements.each(function(linkData) {
                            const targetId = linkData.target.id || linkData.target;
                            if (targetId === nodeId) {
                                const linkElement = d3.select(this);
                                tracedLinks.add(linkData);

                                // Highlight the link maintaining its original style
                                linkElement
                                    .classed('dimmed', false)
                                    .classed('traced', true)
                                    .transition()
                                    .duration(150) // EXACT duration from original
                                    .style('opacity', '1');

                                // Add flowing particle effect with tracked timeout
                                const particleTimeoutId = setTimeout(() => {
                                    if (!tracebackActive) return; // Double-check before particle creation
                                    createFlowingParticle(linkElement.node(), linkData);
                                }, 25);
                                tracebackTimeouts.push(particleTimeoutId);
                            }
                        });
                    }, 50); // EXACT 50ms delay from original - PERFECT!

                    // CRITICAL: Track the link timeout so it can be cleared
                    tracebackTimeouts.push(linkTimeoutId);
                }, delay);

                tracebackTimeouts.push(timeoutId);
            });
        }

        function createFlowingParticle(linkElement, linkData, color = '#ffff00') {
            if (!linkElement || !linkData.source || !linkData.target) return;

            const sourceX = linkData.source.x || 0;
            const sourceY = linkData.source.y || 0;
            const targetX = linkData.target.x || 0;
            const targetY = linkData.target.y || 0;

            // For traceback, particles should flow FROM target TO source (backward along transmission)
            // This shows the flow of lineage tracing back to its origins
            const particle = svg.select('.main-group')
                .append('circle')
                .attr('r', 3)
                .attr('fill', color)
                .attr('opacity', 0.8)
                .attr('cx', targetX)  // Start at target (more recent node)
                .attr('cy', targetY)
                .style('filter', `drop-shadow(0 0 6px ${color})`)
                .style('pointer-events', 'none');

            // Animate particle flowing backward (from student to teacher, from incarnation to previous life)
            particle
                .transition()
                .duration(600)
                .ease(d3.easeQuadOut)
                .attr('cx', sourceX)  // Flow to source (older node)
                .attr('cy', sourceY)
                .style('opacity', 0)
                .remove();
        }

        function clearTraceback() {
            tracebackActive = false;

            // Clear all pending timeouts to stop animation
            tracebackTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            tracebackTimeouts = [];

            // Stop all transitions
            nodeElements.interrupt();
            linkElements.interrupt();

            // Remove all particles
            svg.selectAll('circle[fill="#ffff00"]').remove();

            tracedNodes.clear();
            tracedLinks.clear();

            // Remove all traceback classes and reset styles
            nodeElements
                .classed('traced', false)
                .classed('target', false)
                .classed('dimmed', false)
                .style('opacity', null)
                .attr('r', d => {
                    // Keep Samantabhadra/Samantabhadri larger even when clearing traceback
                    if (d.name.toLowerCase().includes('samantabhadra') ||
                        d.name.toLowerCase().includes('samantabhadri')) {
                        return 16;
                    }
                    const connections = d.teachers.length + d.students.length;
                    return Math.max(4, Math.min(12, connections * 1.2 + 4));
                });

            linkElements
                .classed('traced', false)
                .classed('dimmed', false)
                .classed('flowing', false)
                .style('opacity', null)
                .style('stroke', null)
                .style('stroke-width', null)
                .style('filter', null)
                .style('stroke-dasharray', null)
                .style('animation', null);

            console.log('Traceback cleared');
        }

        function applyTracebackHighlighting() {
            if (!tracebackActive) return;

            // Highlight traced nodes, dim others
            nodeElements
                .classed('traced', d => tracedNodes.has(d.id))
                .classed('dimmed', d => !tracedNodes.has(d.id));

            // Highlight traced links using ID matching, dim others
            linkElements
                .each(function(d) {
                    const isTraced = [...tracedLinks].some(tracedLink => {
                        const sourceId = d.source.id || d.source;
                        const targetId = d.target.id || d.target;
                        const tracedSourceId = tracedLink.source.id || tracedLink.source;
                        const tracedTargetId = tracedLink.target.id || tracedLink.target;
                        return sourceId === tracedSourceId && targetId === tracedTargetId;
                    });

                    if (isTraced) {
                        d3.select(this)
                            .classed('dimmed', false)
                            .classed('traced', true)
                            .style('stroke', '#ffff00')
                            .style('stroke-width', '4px')
                            .style('opacity', '1');
                    } else {
                        d3.select(this)
                            .classed('dimmed', true)
                            .classed('traced', false);
                    }
                });
        }

        // Panel management functions
        function toggleControls() {
            const controls = document.querySelector('.controls');
            const legend = document.querySelector('.legend');

            // Close legend if open
            if (legend.classList.contains('show')) {
                legend.classList.remove('show');
            }

            controls.classList.toggle('show');
        }

        function toggleLegend() {
            const legend = document.querySelector('.legend');
            const controls = document.querySelector('.controls');

            // Close controls if open
            if (controls.classList.contains('show')) {
                controls.classList.remove('show');
            }

            legend.classList.toggle('show');
        }

        function togglePlaybackSettings() {
            const dropdown = document.getElementById('playback-settings');
            dropdown.classList.toggle('show');
        }

        // Mobile-first behavior - panels start hidden
        function initMobileBehavior() {
            // Panels are hidden by default via CSS transform and opacity
            // No additional initialization needed
        }

        // Search functionality
        let searchResults = [];
        let currentSearchIndex = -1;

        // Initialize search when page loads
        function initializeSearch() {
            const searchInput = document.getElementById('search');
            searchInput.addEventListener('input', function() {
                performSearch(this.value);
            });
        }

        function performSearch(searchTerm) {
            const normalizedSearchTerm = normalizeText(searchTerm.trim());

            // Clear previous search
            clearSearchHighlights();
            searchResults = [];
            currentSearchIndex = -1;

            if (normalizedSearchTerm === '') {
                hideSearchNavigation();
                return;
            }

            // Find all matching nodes - search ALL nodes in visualization, not just current nodeElements
            svg.selectAll('circle').each(function(d) {
                if (!d) return; // Skip if no data

                const normalizedName = normalizeText(d.name || '');
                const normalizedWylie = normalizeText(d.wylie || '');
                const normalizedTibetan = normalizeText(d.tibetan || '');
                const normalizedChinese = normalizeText(d.chinese || '');

                const isMatch = normalizedName.includes(normalizedSearchTerm) ||
                               normalizedWylie.includes(normalizedSearchTerm) ||
                               normalizedTibetan.includes(normalizedSearchTerm) ||
                               normalizedChinese.includes(normalizedSearchTerm);

                if (isMatch) {
                    searchResults.push({
                        element: this,
                        data: d
                    });
                    // Highlight the matching node - apply directly to the circle element
                    d3.select(this).classed('search-highlight', true);
                } else {
                    // Dim non-matching nodes
                    d3.select(this)
                        .classed('search-highlight', false)
                        .style('opacity', 0.2);
                }
            });

            // Update navigation UI
            if (searchResults.length > 0) {
                showSearchNavigation();
                currentSearchIndex = 0;
                highlightCurrentResult();
                // DO NOT auto-zoom - just highlight
            } else {
                hideSearchNavigation();
            }
        }

        function showSearchNavigation() {
            document.getElementById('search-navigation').style.display = 'flex';
            updateSearchCounter();
            updateNavigationButtons();
        }

        function hideSearchNavigation() {
            document.getElementById('search-navigation').style.display = 'none';
            svg.selectAll('circle').style('opacity', 1);
        }

        function updateSearchCounter() {
            const counter = document.getElementById('search-counter');
            if (searchResults.length > 0) {
                counter.textContent = `${currentSearchIndex + 1} / ${searchResults.length}`;
            } else {
                counter.textContent = '0 / 0';
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('search-prev');
            const nextBtn = document.getElementById('search-next');

            // Always enable buttons when there are search results (since we cycle infinitely)
            const hasResults = searchResults.length > 0;
            prevBtn.disabled = !hasResults;
            nextBtn.disabled = !hasResults;
        }

        function clearSearchHighlights() {
            svg.selectAll('circle')
                .classed('search-highlight', false)
                .classed('search-flash', false)
                .classed('search-current', false)
                .style('opacity', 1);
        }

        function highlightCurrentResult() {
            // Clear previous current highlights
            d3.selectAll('.search-current').classed('search-current', false);
            d3.selectAll('.search-flash').classed('search-flash', false);

            // Make current result VERY visible
            if (currentSearchIndex >= 0 && currentSearchIndex < searchResults.length) {
                const element = d3.select(searchResults[currentSearchIndex].element);

                // Add bright highlighting - apply directly to the circle
                element.classed('search-current', true);
                element.classed('search-flash', true);

                // Flash for attention, then keep bright highlighting
                setTimeout(() => {
                    element.classed('search-flash', false);
                    // Keep search-current class for persistent bright highlighting
                }, 3000); // Flash for 3 seconds
            }
        }

        function zoomToCurrentResult() {
            if (currentSearchIndex < 0 || currentSearchIndex >= searchResults.length) return;

            const result = searchResults[currentSearchIndex];
            const nodeData = result.data;

            // Get node position
            const nodeX = nodeData.x || 0;
            const nodeY = nodeData.y || 0;

            // Calculate zoom transform to center on this node - zoom in closer
            const scale = 2.5; // Much closer zoom level
            const translateX = width / 2 - nodeX * scale;
            const translateY = height / 2 - nodeY * scale;

            const transform = d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(scale);

            svg.transition()
                .duration(800)
                .ease(d3.easeCubicInOut)
                .call(zoomBehavior.transform, transform);
        }

        function nextSearchResult() {
            if (searchResults.length === 0) return;

            // Cycle through results: after last result, go back to first
            currentSearchIndex = (currentSearchIndex + 1) % searchResults.length;
            highlightCurrentResult();
            zoomToCurrentResult();
            updateSearchCounter();
            updateNavigationButtons();
        }

        function previousSearchResult() {
            if (searchResults.length === 0) return;

            // Cycle through results: before first result, go to last
            currentSearchIndex = (currentSearchIndex - 1 + searchResults.length) % searchResults.length;
            highlightCurrentResult();
            zoomToCurrentResult();
            updateSearchCounter();
            updateNavigationButtons();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            init();
            initializeSearch();
            // Initialize language display
            updateAllUILanguage();
        });

        // Add body click listener to clear traceback and close popup
        document.addEventListener('click', function(event) {
            // Check if clicking on a node or control element
            const clickedOnNode = event.target.closest('.node') || event.target.closest('circle');
            const clickedOnControls = event.target.closest('.controls');
            const clickedOnControlsIcon = event.target.closest('#controls-icon');
            const clickedOnLegend = event.target.closest('.legend');
            const clickedOnLegendIcon = event.target.closest('#legend-icon');
            const clickedOnPopup = event.target.closest('.popup-card');

            // Close panels if clicking outside
            if (!clickedOnControls && !clickedOnControlsIcon) {
                document.querySelector('.controls').classList.remove('show');
            }
            if (!clickedOnLegend && !clickedOnLegendIcon) {
                document.querySelector('.legend').classList.remove('show');
            }

            // Only clear/close if clicking outside of interactive elements
            if (!clickedOnNode && !clickedOnControls && !clickedOnPopup && !clickedOnControlsIcon && !clickedOnLegend && !clickedOnLegendIcon) {
                // Clear traceback
                if (tracebackActive) {
                    clearTraceback();
                }

                // Close popup
                const popup = document.getElementById('popup-card');
                if (popup && !popup.classList.contains('hidden')) {
                    closePopup();
                }

                // Clear search highlights if any
                if (searchResults.length > 0) {
                    document.getElementById('search').value = '';
                    clearSearchHighlights();
                    searchResults = [];
                    currentSearchIndex = -1;
                    hideSearchNavigation();
                }
            }
        });

        // Popup functionality
        function showPopup(data, event) {
            const popup = document.getElementById('popup-card');
            const title = document.getElementById('popup-title');
            const imagesContainer = document.getElementById('popup-images');
            const tibetan = document.getElementById('popup-tibetan');
            const dates = document.getElementById('popup-dates');
            const description = document.getElementById('popup-description');

            // Store current popup info
            currentPopupData = data;
            currentPopupNode = event.target;

            // Set content with language-aware display
            title.textContent = getDisplayName(data) || data.id;

            // Clear and hide images container initially
            imagesContainer.innerHTML = '';
            imagesContainer.style.display = 'none';

            // Load images asynchronously
            loadNodeImages(data.name || data.id).then(images => {
                if (images.length > 0) {
                    displayImageCarousel(imagesContainer, images);
                } else {
                    imagesContainer.style.display = 'none';
                }
            }).catch(error => {
                console.log('Error loading images:', error);
                imagesContainer.style.display = 'none';
            });

            // Tibetan/Wylie name
            const wylieName = data.wylie || '';
            if (wylieName && wylieName !== 'N/A' && wylieName.trim()) {
                tibetan.innerHTML = `<em>Wylie:</em> ${wylieName}`;
                tibetan.style.display = 'block';
            } else {
                tibetan.style.display = 'none';
            }

            // Dates
            const dateInfo = data.dates || '';
            if (dateInfo && dateInfo !== 'N/A' && dateInfo.toString().trim()) {
                dates.innerHTML = `<strong>Dates:</strong> ${dateInfo}`;
                dates.style.display = 'block';
            } else {
                dates.style.display = 'none';
            }

            // Description with language-aware display
            const desc = getDisplayDescription(data);
            if (desc && desc.trim()) {
                description.innerHTML = desc;
                description.style.display = 'block';
            } else {
                description.style.display = 'none';
            }

            // Image subtext
            const imgSubtextContainer = document.getElementById('popup-img-subtext');
            const imgSubtext = data.imgSubtext || '';
            if (imgSubtext && imgSubtext.trim()) {
                imgSubtextContainer.innerHTML = imgSubtext;
                imgSubtextContainer.style.display = 'block';
            } else {
                imgSubtextContainer.style.display = 'none';
            }

            // Links section
            const linksContainer = document.getElementById('popup-links');
            const linksNames = data.linksNames || '';
            const linksUrls = data.linksUrls || '';

            if (linksNames && linksNames.trim() && linksUrls && linksUrls.trim()) {
                const namesArray = linksNames.split(';').map(name => name.trim()).filter(name => name);
                const urlsArray = linksUrls.split(';').map(url => url.trim()).filter(url => url);

                if (namesArray.length > 0 && urlsArray.length > 0) {
                    let linksHTML = '<h4>Links</h4>';

                    // Pair each name with corresponding URL (1:1 mapping)
                    for (let i = 0; i < Math.min(namesArray.length, urlsArray.length); i++) {
                        const name = namesArray[i];
                        const url = urlsArray[i];
                        if (name && url) {
                            linksHTML += `<a href="${url}" target="_blank" rel="noopener noreferrer">${name}</a>`;
                        }
                    }

                    linksContainer.innerHTML = linksHTML;
                    linksContainer.style.display = 'block';
                } else {
                    linksContainer.style.display = 'none';
                }
            } else {
                linksContainer.style.display = 'none';
            }

            // Show popup
            popup.classList.remove('hidden');
        }

        function closePopup() {
            const popup = document.getElementById('popup-card');
            popup.classList.add('hidden');
            currentPopupNode = null;
            currentPopupData = null;
        }

        function updatePopupLanguage(data) {
            if (!data) return;

            // Update title
            const title = document.getElementById('popup-title');
            if (title) {
                title.textContent = getDisplayName(data) || data.id;
            }

            // Update description
            const description = document.getElementById('popup-description');
            if (description) {
                const desc = getDisplayDescription(data);
                if (desc && desc.trim()) {
                    description.innerHTML = desc;
                    description.style.display = 'block';
                } else {
                    description.style.display = 'none';
                }
            }

            // Apply language-specific styling to popup
            const popup = document.getElementById('popup-card');
            if (popup) {
                popup.className = popup.className.replace(/\b(english|tibetan|chinese)-text\b/g, '');
                popup.classList.add(`${currentLanguage}-text`);
                popup.style.fontFamily = getCurrentLanguageFont();
            }
        }

        // Text normalization for image filenames (copied from original)
        function normalizeText(text) {
            if (!text || typeof text !== 'string') return '';

            return text.toLowerCase()
                .replace(/\//g, '-')
                .replace(/\./g, '')
                .replace(/[āàáâãäå]/g, 'a')
                .replace(/[èéêë]/g, 'e')
                .replace(/[ìíîï]/g, 'i')
                .replace(/[òóôõö]/g, 'o')
                .replace(/[ùúûü]/g, 'u')
                .replace(/[ýÿ]/g, 'y')
                .replace(/[ñń]/g, 'n')
                .replace(/[ç]/g, 'c')
                .replace(/[ś]/g, 's')
                .replace(/[ṭ]/g, 't')
                .replace(/[ḍ]/g, 'd')
                .replace(/[ṇ]/g, 'n')
                .replace(/[ṁṃ]/g, 'm')
                .replace(/[ṛ]/g, 'r')
                .replace(/[ḷ]/g, 'l')
                .replace(/[ḥ]/g, 'h')
                .replace(/[ī]/g, 'i')
                .replace(/[ū]/g, 'u')
                .replace(/[ṅ]/g, 'n')
                .replace(/[ḻ]/g, 'l')
                .replace(/[^\w\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '');
        }

        // Image manifest system
        async function loadImageManifest() {
            if (manifestLoadPromise) {
                return manifestLoadPromise;
            }

            manifestLoadPromise = (async () => {
                try {
                    console.log('Loading image manifest...');
                    const response = await fetch('./image-manifest.json');
                    if (response.ok) {
                        imageManifest = await response.json();
                        console.log(`✅ Image manifest loaded: ${Object.keys(imageManifest).length} nodes with images`);
                        return imageManifest;
                    } else {
                        console.warn('⚠️ Image manifest not found, falling back to individual image checking');
                        return null;
                    }
                } catch (error) {
                    console.warn('⚠️ Failed to load image manifest:', error);
                    return null;
                }
            })();

            return manifestLoadPromise;
        }

        // Image loading system
        async function loadNodeImages(nodeName) {
            const normalizedName = normalizeText(nodeName);

            // Ensure manifest is loaded
            const manifest = await loadImageManifest();

            if (manifest && manifest[normalizedName]) {
                // Instant lookup from manifest - no network requests!
                console.log(`Found ${manifest[normalizedName].length} images for: ${nodeName}`);
                return manifest[normalizedName];
            }

            // Fallback to basic filename check if manifest not available
            console.log(`No images found in manifest for: ${normalizedName}`);

            // Try common image extensions for the normalized name
            const extensions = ['jpg', 'jpeg', 'png', 'webp'];
            const imagePromises = extensions.map(ext => {
                const imagePath = `./images/${normalizedName}.${ext}`;
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve(imagePath);
                    img.onerror = () => resolve(null);
                    img.src = imagePath;
                });
            });

            const results = await Promise.all(imagePromises);
            const validImages = results.filter(path => path !== null);

            if (validImages.length > 0) {
                console.log(`Found ${validImages.length} images via fallback for: ${nodeName}`);
            }

            return validImages;
        }

        function displayImageCarousel(container, images) {
            container.innerHTML = '';

            if (images.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            if (images.length === 1) {
                container.innerHTML = `
                    <div class="image-carousel">
                        <img src="${images[0]}" alt="Node image" class="carousel-image"
                             onload="this.style.opacity='1'"
                             onerror="this.parentElement.parentElement.style.display='none'"
                             style="opacity:0; transition: opacity 0.3s ease;">
                    </div>
                `;
            } else {
                let carouselHTML = `
                    <div class="image-carousel">
                        <div class="carousel-container">
                            ${images.map((img, index) => `
                                <img src="${img}" alt="Node image" class="carousel-image"
                                     onload="this.style.opacity='1'"
                                     onerror="this.style.display='none'"
                                     style="opacity:0; transition: opacity 0.3s ease;">
                            `).join('')}
                        </div>
                        <button class="carousel-nav carousel-prev" onclick="prevImage()">&lt;</button>
                        <button class="carousel-nav carousel-next" onclick="nextImage()">&gt;</button>
                    </div>
                    <div class="carousel-dots">
                        ${images.map((_, index) => `<span class="carousel-dot ${index === 0 ? 'active' : ''}" onclick="goToImage(${index})"></span>`).join('')}
                    </div>
                `;
                container.innerHTML = carouselHTML;

                window.currentImageIndex = 0;
                window.totalImages = images.length;
            }
        }

        // Carousel navigation functions
        function prevImage() {
            if (window.totalImages <= 1) return;
            window.currentImageIndex = (window.currentImageIndex - 1 + window.totalImages) % window.totalImages;
            updateCarousel();
        }

        function nextImage() {
            if (window.totalImages <= 1) return;
            window.currentImageIndex = (window.currentImageIndex + 1) % window.totalImages;
            updateCarousel();
        }

        function goToImage(index) {
            window.currentImageIndex = index;
            updateCarousel();
        }

        function updateCarousel() {
            const container = document.querySelector('.carousel-container');
            const dots = document.querySelectorAll('.carousel-dot');

            if (container) {
                const translateX = -window.currentImageIndex * 100;
                container.style.transform = `translateX(${translateX}%)`;
            }

            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === window.currentImageIndex);
            });
        }

        // Add keyboard navigation for search and other functions
        document.addEventListener('keydown', function(event) {
            // Search navigation when search is active
            if (searchResults.length > 0 && document.getElementById('search-navigation').style.display !== 'none') {
                if (event.key === 'ArrowDown' || event.key === 'Enter') {
                    event.preventDefault();
                    nextSearchResult();
                    return;
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    previousSearchResult();
                    return;
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    document.getElementById('search').value = '';
                    performSearch('');
                    return;
                }
            }

            // General escape key handling
            if (event.key === 'Escape') {
                let handled = false;

                if (tracebackActive) {
                    console.log('Escape key pressed - clearing traceback');
                    clearTraceback();
                    handled = true;
                }

                // Check if popup is currently open
                const popup = document.getElementById('popup-card');
                if (popup && !popup.classList.contains('hidden')) {
                    console.log('Escape key pressed - closing popup');
                    closePopup();
                    handled = true;
                }

                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        });
    </script>
</body>
</html>