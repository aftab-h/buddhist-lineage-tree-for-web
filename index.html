<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dzogchen Lineage Tree - Interactive Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        #search {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 200px;
        }

        .filter-btn {
            padding: 6px 12px;
            margin: 2px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .filter-btn:hover {
            background: #f0f0f0;
        }

        .filter-btn.active {
            background: #4CAF50;
            color: white;
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
        }

        .node-text {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }

        .node-date {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            fill: #666;
        }

        .link {
            fill: none;
            stroke-width: 2px;
            stroke-opacity: 0.7;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            font-size: 13px;
            line-height: 1.4;
        }

        .hidden {
            display: none;
        }

        .highlighted {
            stroke-width: 4px !important;
            stroke: #ff6b35 !important;
        }

        .transmission-label {
            font-size: 16px;
            font-weight: bold;
            fill: #444;
            text-anchor: middle;
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <input type="text" id="search" placeholder="Search for a teacher...">
            <div>
                <button class="filter-btn active" data-filter="all">All Lineages</button>
            </div>
        </div>

        <div id="legend">
            <h4 style="margin-top: 0;">Transmission Types</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #4FC3F7;"></div>
                <span>Mind-Mind (Primordial)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #BA68C8;"></div>
                <span>Symbolic Transmission</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #81C784;"></div>
                <span>Aural Lineage</span>
            </div>
        </div>

        <div class="tooltip hidden" id="tooltip"></div>
        <svg id="svg"></svg>
    </div>

    <script>
        // Load CSV data dynamically
        let graphData = null;
        let currentFilter = 'all';

        async function loadCSVData() {
            try {
                const response = await fetch('./data/dzogchen_lineage.csv');
                const csvText = await response.text();
                return csvText;
            } catch (error) {
                console.error('Error loading CSV:', error);
                return null;
            }
        }

        // Parse CSV data
        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = [];
                let inQuotes = false;
                let currentValue = '';
                
                for (let char of line) {
                    if (char === '"' && !inQuotes) {
                        inQuotes = true;
                    } else if (char === '"' && inQuotes) {
                        inQuotes = false;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue.trim());
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                values.push(currentValue.trim());

                const obj = {};
                headers.forEach((header, i) => {
                    obj[header.trim()] = values[i] || '';
                });
                return obj;
            });
        }

        // Identify main transmission spines algorithmically
        function identifyTransmissionSpines(nodes, links) {
            // Main spine entities - these form the core transmission lines
            const spineEntities = {
                vimalamitra: 'Vimalamitra',
                padmasambhava: 'Padmasambhava', 
                vairocana: 'Vairocana'
            };
            
            // Mark nodes with their primary lineage affiliation
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            return spineEntities;
        }
        
        // Mark all nodes with proper lineage affiliation for filtering
        function markAllNodesWithLineage(nodes, links) {
            // Define the main lineage ancestors
            const lineageAncestors = {
                'Vimalamitra': ['Vimalamitra', 'Jñānasūtra', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Padmasambhava': ['Padmasambhava', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Vairocana': ['Vairocana', 'Śrī Siṃha', 'Garab Dorje']
            };
            
            // Helper function to trace lineage ancestry
            function findLineageAncestry(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return null; // Prevent cycles
                visited.add(nodeId);
                
                // Check if this node is a lineage ancestor
                for (const [lineage, ancestors] of Object.entries(lineageAncestors)) {
                    if (ancestors.includes(nodeId)) {
                        return lineage;
                    }
                }
                
                // Check parents recursively
                const parentLinks = links.filter(link => link.target === nodeId);
                for (const link of parentLinks) {
                    const parentLineage = findLineageAncestry(link.source, new Set(visited));
                    if (parentLineage) return parentLineage;
                }
                
                return null;
            }
            
            // Assign lineage to all nodes
            nodes.forEach(node => {
                if (!node.primaryLineage) {
                    // First try to use existing lineage field
                    if (node.lineage && node.lineage !== 'All lineages') {
                        const lineageParts = node.lineage.split(';').map(l => l.trim());
                        for (const part of lineageParts) {
                            if (part.includes('Vimalamitra')) {
                                node.primaryLineage = 'Vimalamitra';
                                break;
                            } else if (part.includes('Padmasambhava')) {
                                node.primaryLineage = 'Padmasambhava';
                                break;
                            } else if (part.includes('Vairocana')) {
                                node.primaryLineage = 'Vairocana';
                                break;
                            }
                        }
                    }
                    
                    // If still no lineage, trace ancestry
                    if (!node.primaryLineage) {
                        node.primaryLineage = findLineageAncestry(node.id) || 'All lineages';
                    }
                }
            });
        }

        // Build node and link data
        function buildGraphData(data) {
            const nodes = new Map();
            const links = [];

            // Create nodes - now including Position_Date!
            data.forEach(person => {
                if (!nodes.has(person.Name_English)) {
                    nodes.set(person.Name_English, {
                        id: person.Name_English,
                        name: person.Name_English,
                        tibetan: person.Name_Wylie_Tibetan,
                        dates: person.Dates,
                        description: person.Description_English,
                        transmissionMode: person.Transmission_Mode,
                        lineage: person.Lineage,
                        positionDate: person.Position_Date, // Key addition!
                        level: 0,
                        children: []
                    });
                }
            });

            // Create links
            data.forEach(person => {
                if (person.Received_Teachings_From) {
                    const teachers = person.Received_Teachings_From.split(';').map(t => t.trim());
                    teachers.forEach(teacher => {
                        if (teacher && nodes.has(teacher) && nodes.has(person.Name_English)) {
                            links.push({
                                source: teacher,
                                target: person.Name_English,
                                lineage: person.Lineage
                            });
                            nodes.get(teacher).children.push(person.Name_English);
                        }
                    });
                }
            });

            // Convert to array and mark lineages
            const nodeArray = Array.from(nodes.values());
            
            // Ensure all nodes have proper lineage marking for filtering
            markAllNodesWithLineage(nodeArray, links);
            
            return {
                nodes: nodeArray,
                links: links
            };
        }

        // Get color based on transmission mode
        function getTransmissionColor(transmissionMode) {
            switch (transmissionMode) {
                case 'Mind to Mind':
                    return '#4FC3F7'; // Blue for Mind-to-Mind transmission
                case 'Symbolic':
                    return '#BA68C8'; // Purple for Symbolic transmission
                case 'Aural':
                    return '#81C784'; // Green for Aural transmission
                default:
                    return '#E0E0E0'; // Gray for unknown/mixed
            }
        }

        // Parse Position_Date and map to reasonable layer levels
        function parsePositionDate(positionDate) {
            if (!positionDate || positionDate === 'N/A' || positionDate === '') {
                return 10; // Put undated entities at layer 10
            }
            
            const rawDate = parseInt(positionDate);
            
            // Map Position_Date values to reasonable layer levels
            if (rawDate === 0) return 0;
            if (rawDate === 1) return 1;
            if (rawDate === 2) return 2;
            if (rawDate === 3) return 3;
            if (rawDate >= 500 && rawDate < 600) return 4; // Garab Dorje at 500
            if (rawDate >= 600 && rawDate < 680) return 5; // Śākyamuni at 600
            if (rawDate >= 680 && rawDate < 700) return 6; // Mañjuśrimitra at 680
            if (rawDate >= 700 && rawDate < 750) return 7; // Śrī Siṃha, Ḍākinīs at 700
            if (rawDate >= 750 && rawDate < 800) return 8; // Padmasambhava, Jñānasūtra at 750
            if (rawDate >= 800 && rawDate < 825) return 9; // Vimalamitra, Vairocana at 800
            if (rawDate >= 825 && rawDate < 900) return 10;
            if (rawDate >= 900 && rawDate < 1000) return 11;
            if (rawDate >= 1000 && rawDate < 1200) return 12;
            if (rawDate >= 1200 && rawDate < 1400) return 13;
            if (rawDate >= 1400) return 14;
            
            return 10; // fallback
        }

        // Assign vertical positions using Position_Date from CSV
        function assignVerticalPositions(nodes, links) {
            // Use Position_Date directly for vertical positioning - this is the key change!
            nodes.forEach(node => {
                node.timeLayer = parsePositionDate(node.positionDate);
                // Convert timeLayer to level for compatibility with existing rendering code
                node.level = node.timeLayer;
            });

            return nodes;
        }

        // Hierarchical Tree Layout with Chronological Constraints
        function applyHierarchicalTreeLayout(nodes, links) {
            console.log('=== HIERARCHICAL TREE LAYOUT START ===');
            
            // Build true parent-child hierarchy
            const hierarchy = buildTreeHierarchy(nodes, links);
            console.log('Tree hierarchy built:', hierarchy);
            
            // Apply D3 tree layout for proper branching
            const treeLayout = d3.tree()
                .size([2000, 1000]) // Much larger canvas for better spreading
                .separation((a, b) => {
                    // Much more separation to prevent overlaps
                    if (a.parent === b.parent) return 3; // Siblings further apart
                    return 5; // Different lineages much further apart
                });
            
            // Process each root node (there might be multiple starting points)
            hierarchy.roots.forEach((root, rootIndex) => {
                const treeData = d3.hierarchy(root, d => d.children);
                const treeNodes = treeLayout(treeData);
                
                // Offset different root trees horizontally
                const rootOffset = rootIndex * 400;
                
                treeNodes.each(node => {
                    // Apply chronological constraints
                    const chronologicalY = node.data.timeLayer * 150; // More vertical space
                    
                    // Use D3's x for horizontal branching, but respect chronology for y
                    node.data.treeX = (node.x / 10) + rootOffset; // Scale down D3's x
                    node.data.treeY = Math.max(node.y / 10, chronologicalY); // Respect both tree depth and chronology
                    
                    console.log(`${node.data.name}: treeX=${node.data.treeX.toFixed(1)}, treeY=${node.data.treeY.toFixed(1)}, timeLayer=${node.data.timeLayer}`);
                });
            });
            
            console.log('=== HIERARCHICAL TREE LAYOUT COMPLETE ===');
            return nodes;
        }
        
        // Build tree hierarchy from parent-child relationships
        function buildTreeHierarchy(nodes, links) {
            console.log('Building tree hierarchy...');
            
            // Create adjacency maps
            const childrenMap = new Map();
            const parentsMap = new Map();
            
            nodes.forEach(node => {
                childrenMap.set(node.id, []);
                parentsMap.set(node.id, []);
            });
            
            links.forEach(link => {
                if (childrenMap.has(link.source) && childrenMap.has(link.target)) {
                    childrenMap.get(link.source).push(link.target);
                    parentsMap.get(link.target).push(link.source);
                }
            });
            
            // Find root nodes (nodes with no parents)
            const rootNodes = nodes.filter(node => {
                const parents = parentsMap.get(node.id) || [];
                return parents.length === 0;
            });
            
            console.log(`Found ${rootNodes.length} root nodes:`, rootNodes.map(n => n.name));
            
            // Build tree structure recursively
            function buildChildren(parentNode) {
                const childIds = childrenMap.get(parentNode.id) || [];
                const children = childIds
                    .map(childId => nodes.find(n => n.id === childId))
                    .filter(child => child);
                    
                children.forEach(child => {
                    child.children = buildChildren(child);
                    child.parent = parentNode;
                });
                
                return children;
            }
            
            // Build full tree structure
            rootNodes.forEach(root => {
                root.children = buildChildren(root);
                root.parent = null;
                root.depth = 0;
            });
            
            return { roots: rootNodes, childrenMap, parentsMap };
        }


        // Initialize visualization
        const container = d3.select('#container');
        const svg = d3.select('#svg');
        const tooltip = d3.select('#tooltip');

        const width = window.innerWidth;
        const height = window.innerHeight;

        svg.attr('width', width).attr('height', height);

        const g = svg.append('g');

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);

        // Initialize the application
        async function initializeApp() {
            const csvData = await loadCSVData();
            if (!csvData) {
                console.error('Failed to load CSV data');
                return;
            }

            // Parse data and build graph
            const rawData = parseCSV(csvData);
            graphData = buildGraphData(rawData);
            
            // Apply hierarchical tree layout with chronological constraints
            assignVerticalPositions(graphData.nodes, graphData.links);
            applyHierarchicalTreeLayout(graphData.nodes, graphData.links);
            
            // Debug: Check everything step by step
            console.log('=== COMPLETE DEBUG ===');
            console.log(`Total nodes: ${graphData.nodes.length}`);
            console.log(`Total links: ${graphData.links.length}`);
            
            // Check if nodes have coordinates
            const nodesWithCoords = graphData.nodes.filter(n => n.x !== undefined && n.y !== undefined);
            console.log(`Nodes with coordinates: ${nodesWithCoords.length}`);
            
            // Sample coordinate check
            graphData.nodes.slice(0, 5).forEach(node => {
                console.log(`${node.name}: x=${node.x}, y=${node.y}, treeX=${node.treeX}, treeY=${node.treeY}`);
            });
            
            // Check if any nodes are positioned
            const xCoords = graphData.nodes.map(n => n.x).filter(x => x !== undefined && !isNaN(x));
            const yCoords = graphData.nodes.map(n => n.y).filter(y => y !== undefined && !isNaN(y));
            
            if (xCoords.length > 0 && yCoords.length > 0) {
                console.log(`X range: ${Math.min(...xCoords)} to ${Math.max(...xCoords)}`);
                console.log(`Y range: ${Math.min(...yCoords)} to ${Math.max(...yCoords)}`);
            } else {
                console.error('ERROR: No valid coordinates found!');
            }

            // Initial render
            renderVisualization(graphData);

            // Reset zoom to show all content - start simple
            console.log('Resetting zoom...');
            
            // Simple zoom reset - no fancy centering until we see the nodes
            const initialTransform = d3.zoomIdentity.translate(0, 0).scale(0.5);
            svg.call(zoom.transform, initialTransform);
            
            console.log('Zoom reset complete');
        }

        function filterData(filter) {
            if (filter === 'all') {
                return graphData;
            }

            const filteredNodes = graphData.nodes.filter(node => 
                node.primaryLineage === filter || 
                node.lineage.includes(filter) || 
                node.lineage.includes('All lineages')
            );
            const filteredNodeIds = new Set(filteredNodes.map(node => node.id));
            const filteredLinks = graphData.links.filter(link => 
                filteredNodeIds.has(link.source) && filteredNodeIds.has(link.target)
            );

            return {
                nodes: filteredNodes,
                links: filteredLinks
            };
        }

        function renderVisualization(data) {
            // Clear previous visualization
            g.selectAll('*').remove();

            // Calculate positions
            const levelGroups = d3.groups(data.nodes, d => d.level);
            const maxLevel = d3.max(levelGroups, d => d[0]);

            // New algorithmic positioning system
            convertAlgorithmicPositionsToPixels(data, width, height);
            
            function convertAlgorithmicPositionsToPixels(data, width, height) {
                const nodes = data.nodes;
                
                // Grid configuration - more spacing to prevent overlaps
                const gridWidth = 200;  // More horizontal pixels per unit
                const gridHeight = 120; // vertical space between generations
                const baseX = 100;      // larger left margin
                const baseY = 50;       // top margin
                
                // Convert tree positions to pixel coordinates - FIXED scaling
                nodes.forEach(node => {
                    let xPos, yPos;
                    
                    if (typeof node.treeX === 'number' && !isNaN(node.treeX)) {
                        // Scale down the D3 tree coordinates with better distribution
                        xPos = node.treeX / 50; // Divide by 50 for more spread (was 100)
                    } else {
                        // Fallback: simple column by lineage
                        if (node.primaryLineage === 'Vimalamitra' || node.lineage?.includes('Vimalamitra')) {
                            xPos = 2;
                        } else if (node.primaryLineage === 'Padmasambhava' || node.lineage?.includes('Padmasambhava')) {
                            xPos = 6;
                        } else if (node.primaryLineage === 'Vairocana' || node.lineage?.includes('Vairocana')) {
                            xPos = 10;
                        } else {
                            xPos = 4; // Center for shared entities
                        }
                    }
                    
                    if (typeof node.treeY === 'number' && !isNaN(node.treeY)) {
                        // Scale down the huge Y coordinates too
                        yPos = node.treeY / 150; // Bring 1500 down to 10
                    } else {
                        yPos = node.level || 0; // Fallback to timeLayer
                    }
                    
                    node.x = baseX + (xPos * gridWidth);
                    node.y = baseY + (yPos * gridHeight);
                    
                    // Debug key nodes
                    if (['Samantabhadra', 'Vimalamitra', 'Śākyamuni Buddha'].includes(node.name)) {
                        console.log(`${node.name}: treeX=${node.treeX} -> scaled=${xPos} -> pixel (${node.x}, ${node.y})`);
                    }
                });
            }

            // Create tree-style links with proper branching
            const links = g.selectAll('.link')
                .data(data.links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d => {
                    const source = data.nodes.find(n => n.id === d.source);
                    const target = data.nodes.find(n => n.id === d.target);
                    if (!source || !target) return '';
                    
                    // Tree-style edge routing - clear parent-child relationships
                    const path = d3.path();
                    const sourceX = source.x;
                    const sourceY = source.y + 25; // Bottom of parent node
                    const targetX = target.x;
                    const targetY = target.y - 25; // Top of child node
                    
                    path.moveTo(sourceX, sourceY);
                    
                    // Tree-like connections: straight down then across
                    const midY = sourceY + (targetY - sourceY) * 0.6;
                    
                    if (Math.abs(sourceX - targetX) < 10) {
                        // Direct parent-child: straight line
                        path.lineTo(targetX, targetY);
                    } else {
                        // Branching: create tree-like elbow connection
                        path.lineTo(sourceX, midY);        // Down from parent
                        path.lineTo(targetX, midY);        // Across to child position
                        path.lineTo(targetX, targetY);     // Down to child
                    }
                    
                    return path.toString();
                })
                .attr('stroke', d => {
                    const sourceNode = data.nodes.find(n => n.id === d.source);
                    return sourceNode ? getTransmissionColor(sourceNode.transmissionMode) : '#666';
                })
                .attr('stroke-width', 2)
                .attr('fill', 'none')
                .attr('opacity', 0.7);

            // Simplified rendering - no background zones or guides for now

            // Create node groups
            const nodeGroups = g.selectAll('.node-group')
                .data(data.nodes)
                .enter()
                .append('g')
                .attr('class', 'node-group')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            // Add node rectangles optimized for tree layout - wider to prevent overlap
            nodeGroups.append('rect')
                .attr('class', 'node')
                .attr('x', -90) // Wider nodes to accommodate longer names
                .attr('y', -25)
                .attr('width', 180) // Increased width
                .attr('height', 50)
                .attr('rx', 8)
                .attr('fill', d => getTransmissionColor(d.transmissionMode))
                .attr('stroke', '#333')
                .attr('stroke-width', 2)
                .attr('opacity', 0.95);

            // Add node text (name) - better text handling with longer names
            nodeGroups.append('text')
                .attr('class', 'node-text')
                .attr('y', -3)
                .attr('font-size', '11px')
                .text(d => d.name.length > 22 ? d.name.substring(0, 20) + '...' : d.name);

            // Add node text (dates) - smaller dates
            nodeGroups.append('text')
                .attr('class', 'node-date')
                .attr('y', 12)
                .attr('font-size', '9px')
                .text(d => d.dates && d.dates !== 'N/A' ? d.dates : '');

            // Add interaction events
            nodeGroups
                .on('mouseover', function(event, d) {
                    tooltip.classed('hidden', false)
                        .html(`
                            <strong>${d.name}</strong><br/>
                            ${d.tibetan ? `<em>${d.tibetan}</em><br/>` : ''}
                            <strong>Dates:</strong> ${d.dates}<br/>
                            <strong>Transmission:</strong> ${d.transmissionMode}<br/>
                            <strong>Lineage:</strong> ${d.lineage}<br/><br/>
                            ${d.description}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mousemove', function(event) {
                    tooltip.style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.classed('hidden', true);
                })
                .on('click', function(event, d) {
                    highlightLineage(d);
                });
        }

        function highlightLineage(node) {
            g.selectAll('.node').classed('highlighted', false);
            g.selectAll('.link').classed('highlighted', false);

            // Highlight connected nodes and links
            const connectedNodes = new Set([node.id]);
            
            // Find all ancestors
            function findAncestors(nodeId) {
                graphData.links.forEach(link => {
                    if (link.target === nodeId) {
                        connectedNodes.add(link.source);
                        findAncestors(link.source);
                    }
                });
            }

            // Find all descendants
            function findDescendants(nodeId) {
                graphData.links.forEach(link => {
                    if (link.source === nodeId) {
                        connectedNodes.add(link.target);
                        findDescendants(link.target);
                    }
                });
            }

            findAncestors(node.id);
            findDescendants(node.id);

            // Highlight nodes
            g.selectAll('.node-group').each(function(d) {
                if (connectedNodes.has(d.id)) {
                    d3.select(this).select('.node').classed('highlighted', true);
                }
            });

            // Highlight links
            g.selectAll('.link').each(function(d) {
                if (connectedNodes.has(d.source) && connectedNodes.has(d.target)) {
                    d3.select(this).classed('highlighted', true);
                }
            });
        }

        // Search functionality
        const searchInput = d3.select('#search');
        searchInput.on('input', function() {
            const searchTerm = this.value.toLowerCase();
            
            g.selectAll('.node-group').each(function(d) {
                const isMatch = d.name.toLowerCase().includes(searchTerm) || 
                               d.tibetan.toLowerCase().includes(searchTerm);
                d3.select(this).style('opacity', searchTerm === '' || isMatch ? 1 : 0.2);
            });
        });

        // Filter functionality
        d3.selectAll('.filter-btn').on('click', function() {
            d3.selectAll('.filter-btn').classed('active', false);
            d3.select(this).classed('active', true);
            
            currentFilter = this.dataset.filter;
            const filteredData = filterData(currentFilter);
            renderVisualization(filteredData);
        });

        // Start the application
        initializeApp();
    </script>
</body>
</html>