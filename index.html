<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dzogchen Lineage Tree - Interactive Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        #search {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 200px;
        }

        .filter-btn {
            padding: 6px 12px;
            margin: 2px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .filter-btn:hover {
            background: #f0f0f0;
        }

        .filter-btn.active {
            background: #4CAF50;
            color: white;
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
        }

        .node-text {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }

        .node-date {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            fill: #666;
        }

        .link {
            fill: none;
            stroke-width: 2px;
            stroke-opacity: 0.7;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            font-size: 13px;
            line-height: 1.4;
        }

        .hidden {
            display: none;
        }

        .highlighted {
            stroke-width: 4px !important;
            stroke: #ff6b35 !important;
        }

        .transmission-label {
            font-size: 16px;
            font-weight: bold;
            fill: #444;
            text-anchor: middle;
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <input type="text" id="search" placeholder="Search for a teacher...">
            <div>
                <button class="filter-btn active" data-filter="all">All Lineages</button>
            </div>
        </div>

        <div id="legend">
            <h4 style="margin-top: 0;">Transmission Types</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #4FC3F7;"></div>
                <span>Mind-Mind (Primordial)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #BA68C8;"></div>
                <span>Symbolic Transmission</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #81C784;"></div>
                <span>Aural Lineage</span>
            </div>
        </div>

        <div class="tooltip hidden" id="tooltip"></div>
        <svg id="svg"></svg>
    </div>

    <script>
        // Load CSV data dynamically
        let graphData = null;
        let currentFilter = 'all';

        async function loadCSVData() {
            try {
                const response = await fetch('./data/dzogchen_lineage.csv');
                const csvText = await response.text();
                return csvText;
            } catch (error) {
                console.error('Error loading CSV:', error);
                return null;
            }
        }

        // Parse CSV data
        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = [];
                let inQuotes = false;
                let currentValue = '';
                
                for (let char of line) {
                    if (char === '"' && !inQuotes) {
                        inQuotes = true;
                    } else if (char === '"' && inQuotes) {
                        inQuotes = false;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue.trim());
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                values.push(currentValue.trim());

                const obj = {};
                headers.forEach((header, i) => {
                    obj[header.trim()] = values[i] || '';
                });
                return obj;
            });
        }

        // Identify main transmission spines algorithmically
        function identifyTransmissionSpines(nodes, links) {
            // Main spine entities - these form the core transmission lines
            const spineEntities = {
                vimalamitra: 'Vimalamitra',
                padmasambhava: 'Padmasambhava', 
                vairocana: 'Vairocana'
            };
            
            // Mark nodes with their primary lineage affiliation
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            return spineEntities;
        }
        
        // Mark all nodes with proper lineage affiliation for filtering
        function markAllNodesWithLineage(nodes, links) {
            // Define the main lineage ancestors
            const lineageAncestors = {
                'Vimalamitra': ['Vimalamitra', 'Jñānasūtra', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Padmasambhava': ['Padmasambhava', 'Śrī Siṃha', 'Mañjuśrimitra', 'Garab Dorje'],
                'Vairocana': ['Vairocana', 'Śrī Siṃha', 'Garab Dorje']
            };
            
            // Helper function to trace lineage ancestry
            function findLineageAncestry(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return null; // Prevent cycles
                visited.add(nodeId);
                
                // Check if this node is a lineage ancestor
                for (const [lineage, ancestors] of Object.entries(lineageAncestors)) {
                    if (ancestors.includes(nodeId)) {
                        return lineage;
                    }
                }
                
                // Check parents recursively
                const parentLinks = links.filter(link => link.target === nodeId);
                for (const link of parentLinks) {
                    const parentLineage = findLineageAncestry(link.source, new Set(visited));
                    if (parentLineage) return parentLineage;
                }
                
                return null;
            }
            
            // Assign lineage to all nodes
            nodes.forEach(node => {
                if (!node.primaryLineage) {
                    // First try to use existing lineage field
                    if (node.lineage && node.lineage !== 'All lineages') {
                        const lineageParts = node.lineage.split(';').map(l => l.trim());
                        for (const part of lineageParts) {
                            if (part.includes('Vimalamitra')) {
                                node.primaryLineage = 'Vimalamitra';
                                break;
                            } else if (part.includes('Padmasambhava')) {
                                node.primaryLineage = 'Padmasambhava';
                                break;
                            } else if (part.includes('Vairocana')) {
                                node.primaryLineage = 'Vairocana';
                                break;
                            }
                        }
                    }
                    
                    // If still no lineage, trace ancestry
                    if (!node.primaryLineage) {
                        node.primaryLineage = findLineageAncestry(node.id) || 'All lineages';
                    }
                }
            });
        }

        // Build node and link data
        function buildGraphData(data) {
            const nodes = new Map();
            const links = [];

            // Create nodes - now including Position_Date!
            data.forEach(person => {
                if (!nodes.has(person.Name_English)) {
                    nodes.set(person.Name_English, {
                        id: person.Name_English,
                        name: person.Name_English,
                        tibetan: person.Name_Wylie_Tibetan,
                        dates: person.Dates,
                        description: person.Description_English,
                        transmissionMode: person.Transmission_Mode,
                        lineage: person.Lineage,
                        positionDate: person.Position_Date, // Key addition!
                        level: 0,
                        children: []
                    });
                }
            });

            // Create links
            data.forEach(person => {
                if (person.Received_Teachings_From) {
                    const teachers = person.Received_Teachings_From.split(';').map(t => t.trim());
                    teachers.forEach(teacher => {
                        if (teacher && nodes.has(teacher) && nodes.has(person.Name_English)) {
                            links.push({
                                source: teacher,
                                target: person.Name_English,
                                lineage: person.Lineage
                            });
                            nodes.get(teacher).children.push(person.Name_English);
                        }
                    });
                }
            });

            // Convert to array and mark lineages
            const nodeArray = Array.from(nodes.values());
            
            // Ensure all nodes have proper lineage marking for filtering
            markAllNodesWithLineage(nodeArray, links);
            
            return {
                nodes: nodeArray,
                links: links
            };
        }

        // Get color based on transmission mode
        function getTransmissionColor(transmissionMode) {
            switch (transmissionMode) {
                case 'Mind to Mind':
                    return '#4FC3F7'; // Blue for Mind-to-Mind transmission
                case 'Symbolic':
                    return '#BA68C8'; // Purple for Symbolic transmission
                case 'Aural':
                    return '#81C784'; // Green for Aural transmission
                default:
                    return '#E0E0E0'; // Gray for unknown/mixed
            }
        }

        // Parse Position_Date and map to reasonable layer levels
        function parsePositionDate(positionDate) {
            if (!positionDate || positionDate === 'N/A' || positionDate === '') {
                return 10; // Put undated entities at layer 10
            }
            
            const rawDate = parseInt(positionDate);
            
            // Map Position_Date values to reasonable layer levels
            if (rawDate === 0) return 0;
            if (rawDate === 1) return 1;
            if (rawDate === 2) return 2;
            if (rawDate === 3) return 3;
            if (rawDate >= 500 && rawDate < 600) return 4; // Garab Dorje at 500
            if (rawDate >= 600 && rawDate < 680) return 5; // Śākyamuni at 600
            if (rawDate >= 680 && rawDate < 700) return 6; // Mañjuśrimitra at 680
            if (rawDate >= 700 && rawDate < 750) return 7; // Śrī Siṃha, Ḍākinīs at 700
            if (rawDate >= 750 && rawDate < 800) return 8; // Padmasambhava, Jñānasūtra at 750
            if (rawDate >= 800 && rawDate < 825) return 9; // Vimalamitra, Vairocana at 800
            if (rawDate >= 825 && rawDate < 900) return 10;
            if (rawDate >= 900 && rawDate < 1000) return 11;
            if (rawDate >= 1000 && rawDate < 1200) return 12;
            if (rawDate >= 1200 && rawDate < 1400) return 13;
            if (rawDate >= 1400) return 14;
            
            return 10; // fallback
        }

        // Assign vertical positions using Position_Date from CSV
        function assignVerticalPositions(nodes, links) {
            // Use Position_Date directly for vertical positioning - this is the key change!
            nodes.forEach(node => {
                node.timeLayer = parsePositionDate(node.positionDate);
                // Convert timeLayer to level for compatibility with existing rendering code
                node.level = node.timeLayer;
            });

            return nodes;
        }

        // Sugiyama layered graph algorithm
        function applySugiyamaLayout(nodes, links) {
            console.log('=== SUGIYAMA LAYOUT START ===');
            
            // Step 1: Layer assignment (already done by timeLayer)
            const timeLayers = d3.groups(nodes, d => d.timeLayer);
            timeLayers.sort((a, b) => a[0] - b[0]);
            
            console.log(`Found ${timeLayers.length} time layers:`, timeLayers.map(([layer, nodes]) => `Layer ${layer}: ${nodes.length} nodes`));
            
            // Build adjacency maps
            const childrenMap = new Map();
            const parentsMap = new Map();
            
            nodes.forEach(node => {
                childrenMap.set(node.id, []);
                parentsMap.set(node.id, []);
            });
            
            links.forEach(link => {
                if (childrenMap.has(link.source) && childrenMap.has(link.target)) {
                    childrenMap.get(link.source).push(link.target);
                    parentsMap.get(link.target).push(link.source);
                }
            });
            
            // Step 2: Node ordering within layers to minimize crossings
            timeLayers.forEach(([timeLayer, layerNodes], layerIndex) => {
                console.log(`Processing layer ${timeLayer} with ${layerNodes.length} nodes`);
                
                if (layerIndex === 0) {
                    // First layer: order by lineage preference
                    layerNodes.sort((a, b) => {
                        const aLineage = getLineageOrder(a);
                        const bLineage = getLineageOrder(b);
                        return aLineage - bLineage;
                    });
                } else {
                    // Other layers: order to minimize crossings with previous layer
                    layerNodes.sort((a, b) => {
                        const aParentPos = getAverageParentPosition(a, parentsMap, nodes);
                        const bParentPos = getAverageParentPosition(b, parentsMap, nodes);
                        return aParentPos - bParentPos;
                    });
                }
                
                // Step 3: Assign horizontal positions within layer
                const layerWidth = Math.max(8, layerNodes.length * 1.5); // Dynamic width based on node count
                layerNodes.forEach((node, index) => {
                    // Evenly distribute nodes across layer width
                    node.treeX = (index + 0.5) * (layerWidth / layerNodes.length);
                });
                
                console.log(`Layer ${timeLayer} positions:`, layerNodes.map(n => `${n.name}: ${n.treeX.toFixed(1)}`));
            });
            
            console.log('=== SUGIYAMA LAYOUT COMPLETE ===');
            return nodes;
        }
        
        // Helper: Get lineage ordering preference
        function getLineageOrder(node) {
            if (node.primaryLineage === 'Vimalamitra' || node.lineage?.includes('Vimalamitra')) return 1;
            if (node.primaryLineage === 'Padmasambhava' || node.lineage?.includes('Padmasambhava')) return 2;
            if (node.primaryLineage === 'Vairocana' || node.lineage?.includes('Vairocana')) return 3;
            return 1.5; // Center for shared/primordial entities
        }
        
        // Helper: Get average position of parent nodes
        function getAverageParentPosition(node, parentsMap, allNodes) {
            const parents = parentsMap.get(node.id) || [];
            if (parents.length === 0) {
                return getLineageOrder(node); // Fallback to lineage preference
            }
            
            const parentPositions = parents
                .map(parentId => allNodes.find(n => n.id === parentId))
                .filter(parent => parent && typeof parent.treeX === 'number')
                .map(parent => parent.treeX);
                
            if (parentPositions.length === 0) {
                return getLineageOrder(node);
            }
            
            return parentPositions.reduce((sum, pos) => sum + pos, 0) / parentPositions.length;
        }


        // Initialize visualization
        const container = d3.select('#container');
        const svg = d3.select('#svg');
        const tooltip = d3.select('#tooltip');

        const width = window.innerWidth;
        const height = window.innerHeight;

        svg.attr('width', width).attr('height', height);

        const g = svg.append('g');

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);

        // Initialize the application
        async function initializeApp() {
            const csvData = await loadCSVData();
            if (!csvData) {
                console.error('Failed to load CSV data');
                return;
            }

            // Parse data and build graph
            const rawData = parseCSV(csvData);
            graphData = buildGraphData(rawData);
            
            // Apply Sugiyama layered graph algorithm
            assignVerticalPositions(graphData.nodes, graphData.links);
            applySugiyamaLayout(graphData.nodes, graphData.links);
            
            // Debug: Check positioning of all nodes
            console.log('=== POSITIONING DEBUG ===');
            console.log(`Total nodes: ${graphData.nodes.length}`);
            
            // Group by timeLayer to see distribution
            const layerCounts = {};
            graphData.nodes.forEach(node => {
                const layer = node.timeLayer || 'undefined';
                layerCounts[layer] = (layerCounts[layer] || 0) + 1;
            });
            console.log('Nodes per time layer:', layerCounts);
            
            // Check coordinate ranges
            const xCoords = graphData.nodes.map(n => n.x).filter(x => x !== undefined);
            const yCoords = graphData.nodes.map(n => n.y).filter(y => y !== undefined);
            console.log(`X range: ${Math.min(...xCoords)} to ${Math.max(...xCoords)}`);
            console.log(`Y range: ${Math.min(...yCoords)} to ${Math.max(...yCoords)}`);
            
            // Sample nodes from different layers
            console.log('Sample nodes:');
            [0, 1, 4, 5, 6].forEach(layer => {
                const layerNode = graphData.nodes.find(n => n.timeLayer === layer);
                if (layerNode) {
                    console.log(`Layer ${layer}: ${layerNode.name} at (${layerNode.x}, ${layerNode.y}) - lineage: ${layerNode.primaryLineage}`);
                }
            });

            // Initial render
            renderVisualization(graphData);

            // Center the view initially at top portion of the map
            const bounds = g.node().getBBox();
            const fullWidth = window.innerWidth;
            const fullHeight = window.innerHeight;
            const scale = 0.6;
            const translateX = (fullWidth - bounds.width * scale) / 2 - bounds.x * scale;
            // Position at top portion - show top 25% of the visualization
            const translateY = -bounds.y * scale + 100; // Start from top with some padding
            
            const initialTransform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
            svg.transition().duration(750).call(zoom.transform, initialTransform);
        }

        function filterData(filter) {
            if (filter === 'all') {
                return graphData;
            }

            const filteredNodes = graphData.nodes.filter(node => 
                node.primaryLineage === filter || 
                node.lineage.includes(filter) || 
                node.lineage.includes('All lineages')
            );
            const filteredNodeIds = new Set(filteredNodes.map(node => node.id));
            const filteredLinks = graphData.links.filter(link => 
                filteredNodeIds.has(link.source) && filteredNodeIds.has(link.target)
            );

            return {
                nodes: filteredNodes,
                links: filteredLinks
            };
        }

        function renderVisualization(data) {
            // Clear previous visualization
            g.selectAll('*').remove();

            // Calculate positions
            const levelGroups = d3.groups(data.nodes, d => d.level);
            const maxLevel = d3.max(levelGroups, d => d[0]);

            // New algorithmic positioning system
            convertAlgorithmicPositionsToPixels(data, width, height);
            
            function convertAlgorithmicPositionsToPixels(data, width, height) {
                const nodes = data.nodes;
                
                // Grid configuration - optimized for Sugiyama layout
                const gridWidth = 150; // pixels per grid column
                const gridHeight = 100; // pixels per grid row (tighter vertical spacing)
                const baseX = 50;      // smaller left margin
                const baseY = 50;      // smaller top margin
                
                // Convert algorithmic positions to pixel coordinates
                nodes.forEach(node => {
                    // Use treeX from tree layout algorithm, fallback to center if not set
                    const xPos = (typeof node.treeX === 'number') ? node.treeX : 20;
                    // Use timeLayer (level) for vertical positioning
                    const yPos = node.level;
                    
                    node.x = baseX + (xPos * gridWidth);
                    node.y = baseY + (yPos * gridHeight);
                });
            }

            // Create improved links with better edge routing
            const links = g.selectAll('.link')
                .data(data.links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d => {
                    const source = data.nodes.find(n => n.id === d.source);
                    const target = data.nodes.find(n => n.id === d.target);
                    if (!source || !target) return '';
                    
                    // Improved edge routing - smoother curves, less crossing
                    const path = d3.path();
                    const sourceY = source.y + 25; // Bottom of source node
                    const targetY = target.y - 25; // Top of target node
                    const midY = (sourceY + targetY) / 2;
                    
                    path.moveTo(source.x, sourceY);
                    
                    // Use smoother bezier curves for better visual flow
                    if (Math.abs(source.x - target.x) < 75) {
                        // Nodes are close horizontally - simple curve
                        path.bezierCurveTo(
                            source.x, sourceY + 20,
                            target.x, targetY - 20,
                            target.x, targetY
                        );
                    } else {
                        // Nodes are far apart - more controlled curve
                        path.bezierCurveTo(
                            source.x, midY - 15,
                            target.x, midY + 15,
                            target.x, targetY
                        );
                    }
                    
                    return path.toString();
                })
                .attr('stroke', d => {
                    const sourceNode = data.nodes.find(n => n.id === d.source);
                    return sourceNode ? getTransmissionColor(sourceNode.transmissionMode) : '#E0E0E0';
                })
                .attr('stroke-width', 1.5)
                .attr('fill', 'none')
                .attr('opacity', 0.8);

            // Simplified rendering - no background zones or guides for now

            // Create node groups
            const nodeGroups = g.selectAll('.node-group')
                .data(data.nodes)
                .enter()
                .append('g')
                .attr('class', 'node-group')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            // Add node rectangles with better sizing
            nodeGroups.append('rect')
                .attr('class', 'node')
                .attr('x', -70) // Slightly smaller nodes
                .attr('y', -25)
                .attr('width', 140)
                .attr('height', 50)
                .attr('rx', 6)
                .attr('fill', d => getTransmissionColor(d.transmissionMode))
                .attr('stroke', '#333')
                .attr('stroke-width', 1)
                .attr('opacity', 0.9);

            // Add node text (name) - better text handling
            nodeGroups.append('text')
                .attr('class', 'node-text')
                .attr('y', -3)
                .attr('font-size', '11px')
                .text(d => d.name.length > 18 ? d.name.substring(0, 16) + '...' : d.name);

            // Add node text (dates) - smaller dates
            nodeGroups.append('text')
                .attr('class', 'node-date')
                .attr('y', 12)
                .attr('font-size', '9px')
                .text(d => d.dates && d.dates !== 'N/A' ? d.dates : '');

            // Add interaction events
            nodeGroups
                .on('mouseover', function(event, d) {
                    tooltip.classed('hidden', false)
                        .html(`
                            <strong>${d.name}</strong><br/>
                            ${d.tibetan ? `<em>${d.tibetan}</em><br/>` : ''}
                            <strong>Dates:</strong> ${d.dates}<br/>
                            <strong>Transmission:</strong> ${d.transmissionMode}<br/>
                            <strong>Lineage:</strong> ${d.lineage}<br/><br/>
                            ${d.description}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mousemove', function(event) {
                    tooltip.style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.classed('hidden', true);
                })
                .on('click', function(event, d) {
                    highlightLineage(d);
                });
        }

        function highlightLineage(node) {
            g.selectAll('.node').classed('highlighted', false);
            g.selectAll('.link').classed('highlighted', false);

            // Highlight connected nodes and links
            const connectedNodes = new Set([node.id]);
            
            // Find all ancestors
            function findAncestors(nodeId) {
                graphData.links.forEach(link => {
                    if (link.target === nodeId) {
                        connectedNodes.add(link.source);
                        findAncestors(link.source);
                    }
                });
            }

            // Find all descendants
            function findDescendants(nodeId) {
                graphData.links.forEach(link => {
                    if (link.source === nodeId) {
                        connectedNodes.add(link.target);
                        findDescendants(link.target);
                    }
                });
            }

            findAncestors(node.id);
            findDescendants(node.id);

            // Highlight nodes
            g.selectAll('.node-group').each(function(d) {
                if (connectedNodes.has(d.id)) {
                    d3.select(this).select('.node').classed('highlighted', true);
                }
            });

            // Highlight links
            g.selectAll('.link').each(function(d) {
                if (connectedNodes.has(d.source) && connectedNodes.has(d.target)) {
                    d3.select(this).classed('highlighted', true);
                }
            });
        }

        // Search functionality
        const searchInput = d3.select('#search');
        searchInput.on('input', function() {
            const searchTerm = this.value.toLowerCase();
            
            g.selectAll('.node-group').each(function(d) {
                const isMatch = d.name.toLowerCase().includes(searchTerm) || 
                               d.tibetan.toLowerCase().includes(searchTerm);
                d3.select(this).style('opacity', searchTerm === '' || isMatch ? 1 : 0.2);
            });
        });

        // Filter functionality
        d3.selectAll('.filter-btn').on('click', function() {
            d3.selectAll('.filter-btn').classed('active', false);
            d3.select(this).classed('active', true);
            
            currentFilter = this.dataset.filter;
            const filteredData = filterData(currentFilter);
            renderVisualization(filteredData);
        });

        // Start the application
        initializeApp();
    </script>
</body>
</html>