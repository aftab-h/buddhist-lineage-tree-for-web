<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dzogchen Lineage Tree - Interactive Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        #search {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 200px;
        }

        .filter-btn {
            padding: 6px 12px;
            margin: 2px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .filter-btn:hover {
            background: #f0f0f0;
        }

        .filter-btn.active {
            background: #4CAF50;
            color: white;
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
        }

        .node-text {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }

        .node-date {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            fill: #666;
        }

        .link {
            fill: none;
            stroke-width: 2px;
            stroke-opacity: 0.7;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            font-size: 13px;
            line-height: 1.4;
        }

        .hidden {
            display: none;
        }

        .highlighted {
            stroke-width: 4px !important;
            stroke: #ff6b35 !important;
        }

        .transmission-label {
            font-size: 16px;
            font-weight: bold;
            fill: #444;
            text-anchor: middle;
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <input type="text" id="search" placeholder="Search for a teacher...">
            <div>
                <button class="filter-btn active" data-filter="all">All Lineages</button>
                <button class="filter-btn" data-filter="Vimalamitra">Vimalamitra</button>
                <button class="filter-btn" data-filter="Vairocana">Vairocana</button>
                <button class="filter-btn" data-filter="Padmasambhava">Padmasambhava</button>
            </div>
        </div>

        <div id="legend">
            <h4 style="margin-top: 0;">Transmission Types</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #4FC3F7;"></div>
                <span>Mind-Mind (Primordial)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #BA68C8;"></div>
                <span>Symbolic Transmission</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #81C784;"></div>
                <span>Aural Lineage</span>
            </div>
        </div>

        <div class="tooltip hidden" id="tooltip"></div>
        <svg id="svg"></svg>
    </div>

    <script>
        // Load CSV data dynamically
        let graphData = null;
        let currentFilter = 'all';

        async function loadCSVData() {
            try {
                const response = await fetch('./data/dzogchen_lineage.csv');
                const csvText = await response.text();
                return csvText;
            } catch (error) {
                console.error('Error loading CSV:', error);
                return null;
            }
        }

        // Parse CSV data
        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = [];
                let inQuotes = false;
                let currentValue = '';
                
                for (let char of line) {
                    if (char === '"' && !inQuotes) {
                        inQuotes = true;
                    } else if (char === '"' && inQuotes) {
                        inQuotes = false;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue.trim());
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                values.push(currentValue.trim());

                const obj = {};
                headers.forEach((header, i) => {
                    obj[header.trim()] = values[i] || '';
                });
                return obj;
            });
        }

        // Define columns within each transmission type zone
        function defineTransmissionColumns(nodes) {
            // Define columns within each transmission zone
            const transmissionColumns = {
                // Blue zone (Mind-to-Mind) - single central column
                mindToMind: {
                    column1: [
                        'Samantabhadra',
                        'Samantabhadrī', 
                        'Buddhas of the Five Families',
                        'Supreme Emanation Blessing',
                        'Sublime Wisdom Emanation (Vajradhara)',
                        'Vajrasattva',
                        'Vajrapāṇi',
                        'Cheu Nangwa Dampa Samkyi Mikhyapa',
                        'Śākyamuni Buddha'
                    ]
                },
                
                // Purple zone (Symbolic) - three main columns  
                symbolic: {
                    vimalamitra: ['Garab Dorje', 'Mañjuśrimitra', 'Śrī Siṃha', 'Jñānasūtra', 'Vimalamitra'],
                    padmasambhava: ['Garab Dorje', 'Mañjuśrimitra', 'Śrī Siṃha', 'Padmasambhava'],
                    vairocana: ['Garab Dorje', 'Śrī Siṃha', 'Vairocana']
                },
                
                // Green zone (Aural) - three descendant columns
                aural: {
                    vimalamitra: [
                        'King Trisong Detsen', 'Nyang Tingzin Zanpo', 'Bé Lodrö Wangchuk', 
                        'Drom Rinchen Bar', 'Dangma Lhundrup Gyaltsen', 'Chetsun Sengge Wangchuk',
                        'Zhangtön Tashi Dorje', 'Nyima Bum', 'Guru Jober', 'Trulzhik Senggé Gyabpa',
                        'Melong Dorje', 'Kumārarāja', 'Longchenpa Drime Özer'
                    ],
                    padmasambhava: [
                        'Yeshe Tsogyel', 'Princess Lhacam Pema Sel', 'Pema Ledreltsel/Tsultrim Dorje',
                        'Tulku Legden/Gyalse Legpa', 'Karmapa Rangjung Dorje', 'Gyalwa Yungtön Dorje',
                        'Meban Rinchen Lingpa', 'Rigzin Gödem', 'Jadralwa Zöpa'
                    ],
                    vairocana: [
                        'Pang Sang-gyé Gönpo', 'Ngenlam Jangchub Gyaltsen', 'Zadam Rinchenyik',
                        'Khugyur Salwaichok', 'Yudra Nyingpo', 'Aro Yeshe Jungne', 'Setsün',
                        'Jangtön Namdak', 'Kadampa Deshek'
                    ]
                }
            };

            // Mark nodes with their transmission zone and column
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            Object.keys(transmissionColumns).forEach(transmissionType => {
                Object.keys(transmissionColumns[transmissionType]).forEach(columnName => {
                    transmissionColumns[transmissionType][columnName].forEach((nodeName, index) => {
                        const node = nodeMap.get(nodeName);
                        if (node) {
                            node.transmissionZone = transmissionType;
                            node.columnName = columnName;
                            node.positionInColumn = index;
                            node.isInMainColumn = true;
                        }
                    });
                });
            });

            return transmissionColumns;
        }

        // Build node and link data
        function buildGraphData(data) {
            const nodes = new Map();
            const links = [];

            // Create nodes
            data.forEach(person => {
                if (!nodes.has(person.Name_English)) {
                    nodes.set(person.Name_English, {
                        id: person.Name_English,
                        name: person.Name_English,
                        tibetan: person.Name_Wylie_Tibetan,
                        dates: person.Dates,
                        description: person.Description_English,
                        transmissionMode: person.Transmission_Mode,
                        lineage: person.Lineage,
                        level: 0,
                        children: []
                    });
                }
            });

            // Create links
            data.forEach(person => {
                if (person.Received_Teachings_From) {
                    const teachers = person.Received_Teachings_From.split(';').map(t => t.trim());
                    teachers.forEach(teacher => {
                        if (teacher && nodes.has(teacher) && nodes.has(person.Name_English)) {
                            links.push({
                                source: teacher,
                                target: person.Name_English,
                                lineage: person.Lineage
                            });
                            nodes.get(teacher).children.push(person.Name_English);
                        }
                    });
                }
            });

            // Define transmission columns and mark nodes
            const nodeArray = Array.from(nodes.values());
            const transmissionColumns = defineTransmissionColumns(nodeArray);
            
            return {
                nodes: nodeArray,
                links: links,
                transmissionColumns: transmissionColumns
            };
        }

        // Get color based on transmission mode
        function getTransmissionColor(transmissionMode) {
            switch (transmissionMode) {
                case 'Mind to Mind':
                    return '#4FC3F7'; // Blue for Mind-to-Mind transmission
                case 'Symbolic':
                    return '#BA68C8'; // Purple for Symbolic transmission
                case 'Aural':
                    return '#81C784'; // Green for Aural transmission
                default:
                    return '#E0E0E0'; // Gray for unknown/mixed
            }
        }

        // Parse dates from various formats and return approximate year
        function parseDate(dateString) {
            if (!dateString || dateString === 'N/A' || dateString === 'Date unknown' || dateString.includes('Beyond time')) {
                return null; // No date available
            }
            
            // Handle century formats like "8th century", "7th to 8th centuries"
            const centuryMatch = dateString.match(/(\d+)(?:th|st|nd|rd)\s+century/i);
            if (centuryMatch) {
                const century = parseInt(centuryMatch[1]);
                return (century - 1) * 100 + 50; // Middle of century (8th century = 750)
            }
            
            // Handle ranges like "1308-1364", "8th-9th centuries"
            const rangeMatch = dateString.match(/(\d{3,4})-(\d{3,4})/);
            if (rangeMatch) {
                return parseInt(rangeMatch[1]); // Take the start year
            }
            
            // Handle single years or "8th century BCE"
            const yearMatch = dateString.match(/(\d{3,4})/);
            if (yearMatch) {
                const year = parseInt(yearMatch[1]);
                // Handle BCE dates
                return dateString.includes('BCE') ? -year : year;
            }
            
            return null; // Couldn't parse
        }

        // Assign levels using three-tier chronological system
        function assignLevels(nodes, links) {
            // Parse dates for all nodes
            nodes.forEach(node => {
                node.parsedDate = parseDate(node.dates);
            });

            // Separate nodes by transmission mode
            const mindToMindNodes = nodes.filter(node => node.transmissionMode === 'Mind to Mind');
            const symbolicNodes = nodes.filter(node => node.transmissionMode === 'Symbolic');
            const auralNodes = nodes.filter(node => node.transmissionMode === 'Aural');

            // Build parent-child relationships for symbolic nodes (relationship-based positioning)
            const childrenMap = new Map();
            const parentsMap = new Map();
            
            symbolicNodes.forEach(node => {
                childrenMap.set(node.id, []);
                parentsMap.set(node.id, []);
            });
            
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode && 
                    sourceNode.transmissionMode === 'Symbolic' && 
                    targetNode.transmissionMode === 'Symbolic') {
                    childrenMap.get(link.source).push(link.target);
                    parentsMap.get(link.target).push(link.source);
                }
            });

            // TIER 1: Mind to Mind (Levels 0-3) - Primordial/Timeless with specific hierarchy
            mindToMindNodes.forEach(node => {
                switch (node.name) {
                    case 'Samantabhadra':
                    case 'Samantabhadrī':
                        node.level = 0; // Very top
                        break;
                    case 'Buddhas of the Five Families':
                        node.level = 1; // Below primordial couple
                        break;
                    case 'Supreme Emanation Blessing':
                    case 'Sublime Wisdom Emanation (Vajradhara)':
                    case 'Vajradhara':
                        node.level = 2; // Below Five Buddha Families
                        break;
                    case 'Vajrapāṇi':
                    case 'Vajrasattva':
                    case 'Cheu Nangwa Dampa Samkyi Mikhyapa':
                        node.level = 3; // Below Vajradhara/Supreme Emanation Blessing
                        break;
                    case 'Śākyamuni Buddha':
                        node.level = 4; // Below Cheu Nangwa Dampa Samkyi Mikhyapa
                        break;
                    default:
                        // Any other Mind to Mind entities
                        node.level = 3; // Default to level 3
                        break;
                }
            });

            // TIER 2: Symbolic (Levels 5-7) - Relationship-based
            const symbolicRoots = symbolicNodes.filter(node => 
                parentsMap.get(node.id)?.length === 0 || !parentsMap.has(node.id)
            );
            
            const queue = symbolicRoots.map(root => ({ id: root.id, level: 5 }));
            const processed = new Set();

            while (queue.length > 0) {
                const { id, level } = queue.shift();
                
                if (processed.has(id)) continue;
                processed.add(id);
                
                const node = symbolicNodes.find(n => n.id === id);
                if (node) {
                    node.level = Math.min(level, 7); // Cap at level 7
                    
                    // Add children
                    const children = childrenMap.get(id) || [];
                    children.forEach(childId => {
                        if (!processed.has(childId)) {
                            queue.push({ id: childId, level: level + 1 });
                        }
                    });
                }
            }

            // TIER 3: Aural (Levels 7+) - Chronologically sorted
            auralNodes.sort((a, b) => {
                const dateA = a.parsedDate || 9999; // Put undated at end
                const dateB = b.parsedDate || 9999;
                return dateA - dateB;
            });

            // Group aural nodes by finer time periods with smart density detection
            function createTimeGroups(auralNodes) {
                const timeGroups = [];
                let currentGroup = [];
                let currentPeriod = null;
                const QUARTER_CENTURY = 25; // Start with 25-year periods
                const MAX_NODES_PER_GROUP = 4; // Maximum nodes before subdividing
                
                auralNodes.forEach(node => {
                    const date = node.parsedDate;
                    const period = date ? Math.floor(date / QUARTER_CENTURY) * QUARTER_CENTURY : 9999;
                    
                    if (currentPeriod === null || period === currentPeriod) {
                        currentGroup.push(node);
                        currentPeriod = period;
                    } else {
                        if (currentGroup.length > 0) {
                            // Check if group is too crowded and needs subdivision
                            if (currentGroup.length > MAX_NODES_PER_GROUP) {
                                const subdivided = subdivideGroup(currentGroup, 10); // 10-year periods
                                timeGroups.push(...subdivided);
                            } else {
                                timeGroups.push([...currentGroup]);
                            }
                        }
                        currentGroup = [node];
                        currentPeriod = period;
                    }
                });
                
                // Handle the last group
                if (currentGroup.length > 0) {
                    if (currentGroup.length > MAX_NODES_PER_GROUP) {
                        const subdivided = subdivideGroup(currentGroup, 10);
                        timeGroups.push(...subdivided);
                    } else {
                        timeGroups.push(currentGroup);
                    }
                }
                
                return timeGroups;
            }
            
            // Subdivide overcrowded groups into smaller time periods
            function subdivideGroup(group, yearSpan) {
                const subGroups = [];
                let currentSubGroup = [];
                let currentSubPeriod = null;
                
                group.forEach(node => {
                    const date = node.parsedDate;
                    const period = date ? Math.floor(date / yearSpan) * yearSpan : 9999;
                    
                    if (currentSubPeriod === null || period === currentSubPeriod) {
                        currentSubGroup.push(node);
                        currentSubPeriod = period;
                    } else {
                        if (currentSubGroup.length > 0) {
                            subGroups.push([...currentSubGroup]);
                        }
                        currentSubGroup = [node];
                        currentSubPeriod = period;
                    }
                });
                
                if (currentSubGroup.length > 0) {
                    subGroups.push(currentSubGroup);
                }
                
                return subGroups;
            }
            
            // Create time groups with enhanced resolution
            const timeGroups = createTimeGroups(auralNodes);

            // Assign levels to aural nodes with transmission-aware positioning
            let currentLevel = 8;
            timeGroups.forEach((group, groupIndex) => {
                if (group.length <= 2) {
                    // Small groups can share a level
                    group.sort((a, b) => {
                        const dateA = a.parsedDate || 9999;
                        const dateB = b.parsedDate || 9999;
                        if (dateA !== dateB) return dateA - dateB;
                        return a.lineage.localeCompare(b.lineage);
                    });
                    
                    group.forEach(node => {
                        node.level = currentLevel;
                    });
                    currentLevel++;
                } else {
                    // Larger groups need transmission-aware sub-positioning
                    const subLevels = arrangeByTransmission(group, links);
                    subLevels.forEach(subGroup => {
                        subGroup.forEach(node => {
                            node.level = currentLevel;
                        });
                        currentLevel++;
                    });
                }
            });
            
            // Helper function to arrange nodes by transmission relationships
            function arrangeByTransmission(nodes, links) {
                const nodeMap = new Map(nodes.map(n => [n.id, n]));
                const children = new Map();
                const parents = new Map();
                
                // Build relationships within this group
                nodes.forEach(node => {
                    children.set(node.id, []);
                    parents.set(node.id, []);
                });
                
                links.forEach(link => {
                    if (nodeMap.has(link.source) && nodeMap.has(link.target)) {
                        children.get(link.source).push(link.target);
                        parents.get(link.target).push(link.source);
                    }
                });
                
                // Find nodes with no parents in this group (teachers)
                const roots = nodes.filter(node => parents.get(node.id).length === 0);
                const remaining = nodes.filter(node => parents.get(node.id).length > 0);
                
                const levels = [];
                if (roots.length > 0) {
                    levels.push(roots.sort((a, b) => (a.parsedDate || 9999) - (b.parsedDate || 9999)));
                }
                if (remaining.length > 0) {
                    levels.push(remaining.sort((a, b) => (a.parsedDate || 9999) - (b.parsedDate || 9999)));
                }
                
                return levels.length > 0 ? levels : [nodes];
            }

            return nodes;
        }

        // Initialize visualization
        const container = d3.select('#container');
        const svg = d3.select('#svg');
        const tooltip = d3.select('#tooltip');

        const width = window.innerWidth;
        const height = window.innerHeight;

        svg.attr('width', width).attr('height', height);

        const g = svg.append('g');

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);

        // Initialize the application
        async function initializeApp() {
            const csvData = await loadCSVData();
            if (!csvData) {
                console.error('Failed to load CSV data');
                return;
            }

            // Parse data and build graph
            const rawData = parseCSV(csvData);
            graphData = buildGraphData(rawData);
            assignLevels(graphData.nodes, graphData.links);

            // Initial render
            renderVisualization(graphData);

            // Center the view initially at top portion of the map
            const bounds = g.node().getBBox();
            const fullWidth = window.innerWidth;
            const fullHeight = window.innerHeight;
            const scale = 0.6;
            const translateX = (fullWidth - bounds.width * scale) / 2 - bounds.x * scale;
            // Position at top portion - show top 25% of the visualization
            const translateY = -bounds.y * scale + 100; // Start from top with some padding
            
            const initialTransform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
            svg.transition().duration(750).call(zoom.transform, initialTransform);
        }

        function filterData(filter) {
            if (filter === 'all') {
                return graphData;
            }

            const filteredNodes = graphData.nodes.filter(node => 
                node.lineage.includes(filter) || node.lineage.includes('All lineages')
            );
            const filteredNodeIds = new Set(filteredNodes.map(node => node.id));
            const filteredLinks = graphData.links.filter(link => 
                filteredNodeIds.has(link.source) && filteredNodeIds.has(link.target)
            );

            return {
                nodes: filteredNodes,
                links: filteredLinks
            };
        }

        function renderVisualization(data) {
            // Clear previous visualization
            g.selectAll('*').remove();

            // Calculate positions
            const levelGroups = d3.groups(data.nodes, d => d.level);
            const maxLevel = d3.max(levelGroups, d => d[0]);

            // Hybrid positioning: levels for transmission zones, columns within zones
            positionNodesWithTransmissionColumns(data, width, height);
            
            function positionNodesWithTransmissionColumns(data, width, height) {
                const nodes = data.nodes;
                const transmissionColumns = data.transmissionColumns;
                
                // Define base Y positions for each transmission zone
                const baseY = 100;
                const levelSpacing = 120;
                
                // Define column positions within each transmission zone
                const columnSpacing = 280;
                const centerX = width / 2;
                
                // Column positions for each zone
                const zoneColumns = {
                    mindToMind: {
                        column1: centerX
                    },
                    symbolic: {
                        vimalamitra: centerX - columnSpacing,
                        padmasambhava: centerX,
                        vairocana: centerX + columnSpacing
                    },
                    aural: {
                        vimalamitra: centerX - columnSpacing,
                        padmasambhava: centerX,
                        vairocana: centerX + columnSpacing
                    }
                };
                
                // Position nodes in main columns using both level and column
                Object.keys(transmissionColumns).forEach(transmissionZone => {
                    Object.keys(transmissionColumns[transmissionZone]).forEach(columnName => {
                        const x = zoneColumns[transmissionZone][columnName];
                        
                        transmissionColumns[transmissionZone][columnName].forEach(nodeName => {
                            const node = nodes.find(n => n.id === nodeName);
                            if (node && x) {
                                node.x = x;
                                // Use the original level-based Y position for transmission type separation
                                node.y = baseY + (node.level * levelSpacing);
                            }
                        });
                    });
                });
                
                // Position side branch nodes
                const sideNodes = nodes.filter(node => !node.isInMainColumn);
                sideNodes.forEach(node => {
                    // Use level-based Y positioning
                    node.y = baseY + (node.level * levelSpacing);
                    
                    // Find parent to position horizontally
                    const parentLink = data.links.find(link => link.target === node.id);
                    if (parentLink) {
                        const parent = nodes.find(n => n.id === parentLink.source);
                        if (parent && parent.x) {
                            // Position to the right of parent 
                            node.x = parent.x + 200;
                        } else {
                            // Default position if no parent found
                            node.x = centerX + columnSpacing * 2;
                        }
                    } else {
                        // No parent, place in side area
                        node.x = centerX + columnSpacing * 2;
                    }
                });
            }

            // Create links
            const links = g.selectAll('.link')
                .data(data.links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d => {
                    const source = data.nodes.find(n => n.id === d.source);
                    const target = data.nodes.find(n => n.id === d.target);
                    if (!source || !target) return '';
                    
                    const path = d3.path();
                    path.moveTo(source.x, source.y + 30);
                    path.bezierCurveTo(
                        source.x, source.y + 60,
                        target.x, target.y - 60,
                        target.x, target.y - 30
                    );
                    return path.toString();
                })
                .attr('stroke', d => {
                    const sourceNode = data.nodes.find(n => n.id === d.source);
                    return sourceNode ? getTransmissionColor(sourceNode.transmissionMode) : '#E0E0E0';
                })
                .attr('stroke-width', 2)
                .attr('fill', 'none');

            // Create transmission zone backgrounds
            const columnSpacing = 280;
            const centerX = width / 2;
            const zoneColors = {
                mindToMind: 'rgba(79, 195, 247, 0.1)',
                symbolic: 'rgba(186, 104, 200, 0.1)', 
                aural: 'rgba(129, 199, 132, 0.1)'
            };
            
            // Create backgrounds for transmission zones
            Object.keys(zoneColors).forEach(zoneName => {
                const zoneNodes = data.nodes.filter(node => {
                    if (zoneName === 'mindToMind') return node.transmissionMode === 'Mind to Mind';
                    if (zoneName === 'symbolic') return node.transmissionMode === 'Symbolic';
                    if (zoneName === 'aural') return node.transmissionMode === 'Aural';
                    return false;
                });
                
                if (zoneNodes.length > 0) {
                    const minY = Math.min(...zoneNodes.map(n => n.y)) - 40;
                    const maxY = Math.max(...zoneNodes.map(n => n.y)) + 80;
                    
                    g.append('rect')
                        .attr('class', 'transmission-zone-background')
                        .attr('x', centerX - columnSpacing * 2)
                        .attr('y', minY)
                        .attr('width', columnSpacing * 4)
                        .attr('height', maxY - minY)
                        .attr('fill', zoneColors[zoneName])
                        .attr('stroke', 'rgba(150, 150, 150, 0.2)')
                        .attr('stroke-width', 1)
                        .attr('rx', 8);
                    
                    // Add zone label
                    let zoneLabel = '';
                    if (zoneName === 'mindToMind') zoneLabel = 'Mind-to-Mind Transmission';
                    if (zoneName === 'symbolic') zoneLabel = 'Symbolic Transmission';
                    if (zoneName === 'aural') zoneLabel = 'Aural Lineage';
                    
                    g.append('text')
                        .attr('class', 'zone-label')
                        .attr('x', centerX - columnSpacing * 1.8)
                        .attr('y', minY + 20)
                        .attr('font-size', '16px')
                        .attr('font-weight', 'bold')
                        .attr('fill', '#444')
                        .text(zoneLabel);
                }
            });

            // Create node groups
            const nodeGroups = g.selectAll('.node-group')
                .data(data.nodes)
                .enter()
                .append('g')
                .attr('class', 'node-group')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            // Add node rectangles
            nodeGroups.append('rect')
                .attr('class', 'node')
                .attr('x', -80)
                .attr('y', -30)
                .attr('width', 160)
                .attr('height', 60)
                .attr('rx', 8)
                .attr('fill', d => getTransmissionColor(d.transmissionMode))
                .attr('stroke', '#333')
                .attr('stroke-width', 1);

            // Add node text (name)
            nodeGroups.append('text')
                .attr('class', 'node-text')
                .attr('y', -5)
                .text(d => d.name.length > 20 ? d.name.substring(0, 18) + '...' : d.name);

            // Add node text (dates)
            nodeGroups.append('text')
                .attr('class', 'node-date')
                .attr('y', 15)
                .text(d => d.dates);

            // Add interaction events
            nodeGroups
                .on('mouseover', function(event, d) {
                    tooltip.classed('hidden', false)
                        .html(`
                            <strong>${d.name}</strong><br/>
                            ${d.tibetan ? `<em>${d.tibetan}</em><br/>` : ''}
                            <strong>Dates:</strong> ${d.dates}<br/>
                            <strong>Transmission:</strong> ${d.transmissionMode}<br/>
                            <strong>Lineage:</strong> ${d.lineage}<br/><br/>
                            ${d.description}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mousemove', function(event) {
                    tooltip.style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.classed('hidden', true);
                })
                .on('click', function(event, d) {
                    highlightLineage(d);
                });
        }

        function highlightLineage(node) {
            g.selectAll('.node').classed('highlighted', false);
            g.selectAll('.link').classed('highlighted', false);

            // Highlight connected nodes and links
            const connectedNodes = new Set([node.id]);
            
            // Find all ancestors
            function findAncestors(nodeId) {
                graphData.links.forEach(link => {
                    if (link.target === nodeId) {
                        connectedNodes.add(link.source);
                        findAncestors(link.source);
                    }
                });
            }

            // Find all descendants
            function findDescendants(nodeId) {
                graphData.links.forEach(link => {
                    if (link.source === nodeId) {
                        connectedNodes.add(link.target);
                        findDescendants(link.target);
                    }
                });
            }

            findAncestors(node.id);
            findDescendants(node.id);

            // Highlight nodes
            g.selectAll('.node-group').each(function(d) {
                if (connectedNodes.has(d.id)) {
                    d3.select(this).select('.node').classed('highlighted', true);
                }
            });

            // Highlight links
            g.selectAll('.link').each(function(d) {
                if (connectedNodes.has(d.source) && connectedNodes.has(d.target)) {
                    d3.select(this).classed('highlighted', true);
                }
            });
        }

        // Search functionality
        const searchInput = d3.select('#search');
        searchInput.on('input', function() {
            const searchTerm = this.value.toLowerCase();
            
            g.selectAll('.node-group').each(function(d) {
                const isMatch = d.name.toLowerCase().includes(searchTerm) || 
                               d.tibetan.toLowerCase().includes(searchTerm);
                d3.select(this).style('opacity', searchTerm === '' || isMatch ? 1 : 0.2);
            });
        });

        // Filter functionality
        d3.selectAll('.filter-btn').on('click', function() {
            d3.selectAll('.filter-btn').classed('active', false);
            d3.select(this).classed('active', true);
            
            currentFilter = this.dataset.filter;
            const filteredData = filterData(currentFilter);
            renderVisualization(filteredData);
        });

        // Start the application
        initializeApp();
    </script>
</body>
</html>