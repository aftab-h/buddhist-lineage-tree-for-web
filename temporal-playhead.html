<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buddhist Lineage - Temporal Playhead Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Tibetan:wght@400;600&family=Noto+Sans+SC:wght@400;600&display=swap');

        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', 'Noto Sans Tibetan', 'Noto Sans SC', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        svg {
            width: 100%;
            height: 100%;
            background: #0a0a0a;
        }

        /* Node Styles */
        .node {
            cursor: pointer;
            stroke-width: 1.5px;
            opacity: 0.9;
        }

        /* Default white color for unknown/invalid transmission modes */
        .node {
            fill: #ffffff;
            stroke: #cccccc;
        }

        .node.mind-to-mind {
            fill: #4a90e2;
            stroke: #357abd;
        }

        .node.symbolic {
            fill: #9b59b6;
            stroke: #7d3c98;
        }

        .node.aural {
            fill: #27ae60;
            stroke: #1e8449;
        }

        .node:hover {
            opacity: 1;
            stroke-width: 3px;
        }

        /* Link Styles */
        .link {
            fill: none;
            stroke-width: 1.5px;
            opacity: 0.7;
        }

        .link.teaching {
            stroke: #ffffff;
            stroke-width: 1px;
        }

        .link.incarnation {
            stroke: #888888;
            stroke-dasharray: 2,2;
        }

        .link.family {
            stroke: #cd853f;
            stroke-dasharray: 5,3;
        }

        .link.emanation {
            stroke: #ffd700;
            stroke-dasharray: 1,1;
        }

        /* Traceback highlighting styles */
        .node.traced {
            stroke: #ffff00 !important;
            stroke-width: 3px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 10px #ffff00);
        }

        .link.traced {
            stroke: #ffff00 !important;
            stroke-width: 4px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 8px #ffff00);
            stroke-dasharray: 10 5;
            animation: flowBack 1.5s linear infinite;
        }

        @keyframes flowBack {
            0% {
                stroke-dashoffset: 15;
            }
            100% {
                stroke-dashoffset: 0;
            }
        }

        .link.traced.flowing {
            animation: flowBack 1.2s ease-in-out infinite;
        }

        .node.dimmed {
            opacity: 0.2 !important;
        }

        .link.dimmed {
            opacity: 0.1 !important;
        }

        /* Controls */
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            min-width: 250px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #ffffff;
        }

        .control-group button {
            margin-right: 5px;
            margin-bottom: 5px;
            padding: 5px 10px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
        }

        .control-group button:hover {
            background: #444;
        }

        .control-group button.active {
            background: #4a90e2;
            border-color: #357abd;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        /* Time playhead styles */
        .time-playhead {
            background: linear-gradient(90deg, #4a90e2 0%, #27ae60 50%, #9b59b6 100%);
            height: 8px;
            border-radius: 4px;
        }

        .time-display {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            margin-top: 5px;
            color: #4a90e2;
        }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
        }

        .legend h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }


        /* Time axis styles */
        .time-axis {
            stroke: #444;
            stroke-width: 1px;
        }

        .time-label {
            fill: #888;
            font-size: 24px;
            text-anchor: middle;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 12px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border: 1px solid #333;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
        }
    </style>
</head>

<body>
    <div id="container">
        <svg id="visualization"></svg>


        <div class="controls">
            <div class="control-group">
                <label>Time Playhead</label>
                <input type="range" id="timeSlider" min="0" max="100" value="100" class="time-playhead">
                <div class="time-display" id="timeDisplay">Year: 2000</div>
            </div>

            <div class="control-group">
                <label>Play Controls</label>
                <button onclick="playTime()">▶ Play</button>
                <button onclick="pauseTime()">⏸ Pause</button>
                <button onclick="resetTime()">⏮ Reset</button>
            </div>

            <div class="control-group">
                <label>Animation Speed</label>
                <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
            </div>

            <div class="control-group">
                <label>Layout Force</label>
                <input type="range" id="forceStrength" min="0" max="100" value="30">
            </div>

            <div class="control-group">
                <label>Filter by Transmission</label>
                <button onclick="filterTransmission('all')" class="active">All</button>
                <button onclick="filterTransmission('Mind to Mind')">Mind</button>
                <button onclick="filterTransmission('Symbolic')">Symbolic</button>
                <button onclick="filterTransmission('Aural')">Aural</button>
            </div>

            <div class="control-group">
                <label>Filter by Lineage</label>
                <button onclick="filterLineage('all')" class="active">All</button>
                <button onclick="filterLineage('Vairocana')">Vairocana</button>
                <button onclick="filterLineage('Vimalamitra')">Vimalamitra</button>
                <button onclick="filterLineage('Padmasambhava')">Padmasambhava</button>
            </div>

            <div class="control-group">
                <label>Layout Mode</label>
                <button onclick="setLayoutMode('circular')" class="active" id="circular-btn">Circular</button>
                <button onclick="setLayoutMode('linear')" id="linear-btn">Linear</button>
            </div>
        </div>

        <div class="legend">
            <h4>Transmission Modes</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                Mind-to-Mind
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9b59b6;"></div>
                Symbolic
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #27ae60;"></div>
                Aural
            </div>

            <h4 style="margin-top: 15px;">Relationship Types</h4>
            <div class="legend-item">
                <span style="margin-right: 8px;">━━━</span> Teaching
            </div>
            <div class="legend-item">
                <span style="margin-right: 8px;">┅┅┅</span> Incarnation
            </div>
            <div class="legend-item">
                <span style="margin-right: 8px;">╌╌╌</span> Family
            </div>
            <div class="legend-item">
                <span style="margin-right: 8px;">···</span> Emanation
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let simulation;
        let svg;
        let nodes = [];
        let links = [];
        let nodeElements;
        let linkElements;
        let tooltip;
        let currentTime = 100; // Current time position (0-100)
        let isPlaying = false;
        let playInterval;
        let animationSpeed = 1;

        // Filters
        let currentFilter = 'all';
        let currentLineageFilter = 'all';
        let layoutMode = 'circular'; // 'linear' or 'circular'
        let densitySensitivity = 1.0;
        let tracebackActive = false;
        let tracedNodes = new Set();
        let tracedLinks = new Set();
        let tracebackTimeouts = []; // Track animation timeouts

        // Drag tracking for click vs drag detection
        let dragStart = { x: 0, y: 0 };
        let isDragging = false;

        // Dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = Math.min(width, height) * 0.4;
        const margin = { top: 50, right: 50, bottom: 100, left: 50 };

        // Initialize visualization
        function init() {
            // Setup SVG
            svg = d3.select('#visualization')
                .attr('width', width)
                .attr('height', height);

            // Create tooltip
            tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Setup zoom
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    svg.select('.main-group').attr('transform', event.transform);
                });

            svg.call(zoom);

            // Add click-away functionality to clear traceback
            svg.on('click', function(event) {
                if (event.target === this) {
                    clearTraceback();
                }
            });

            // Create main group for all elements
            svg.append('g').attr('class', 'main-group');

            // Setup event listeners
            setupEventListeners();

            // Load data
            loadData();
        }

        function setupEventListeners() {
            // Time slider
            document.getElementById('timeSlider').addEventListener('input', function() {
                currentTime = parseFloat(this.value);
                updateTimeDisplay();
                updateVisualization();
            });

            // Speed slider
            document.getElementById('speedSlider').addEventListener('input', function() {
                animationSpeed = parseFloat(this.value);
            });

            // Force strength slider
            document.getElementById('forceStrength').addEventListener('input', function() {
                if (simulation) {
                    const strength = -parseInt(this.value);
                    simulation.force('charge').strength(strength);
                    simulation.alpha(0.3).restart();
                }
            });
        }

        async function loadData() {
            try {
                const response = await fetch('./data/dzogchen_lineage.csv');
                const csvText = await response.text();

                const parsedData = parseCSV(csvText);
                processData(parsedData);
                createVisualization();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));

            return lines.slice(1).map(line => {
                const values = parseCSVLine(line);
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                return row;
            });
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim().replace(/"/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim().replace(/"/g, ''));
            return values;
        }

        function processData(data) {
            // Process nodes
            nodes = data.map(d => {
                const positionDate = parseFloat(d.Position_Date) || 0;
                return {
                    id: d.Name_English,
                    name: d.Name_English,
                    transmission: d.Transmission_Mode || 'Aural',
                    lineage: d.Lineage || 'All lineages',
                    position: positionDate,
                    teachers: (d.Received_Teachings_From || '').split(';').filter(t => t.trim()),
                    students: (d.Gave_Teachings_To || '').split(';').filter(s => s.trim()),
                    incarnationOf: (d.Incarnation_Of || '').split(';').filter(i => i.trim()),
                    familyFrom: (d.Family_Received_From || '').split(';').filter(f => f.trim()),
                    emanatedAs: (d['Eminated as'] || '').split(';').filter(e => e.trim())
                };
            });

            // Process links
            links = [];
            nodes.forEach(node => {
                // Teaching relationships
                node.teachers.forEach(teacherName => {
                    const teacher = nodes.find(n => n.id === teacherName.trim());
                    if (teacher) {
                        links.push({
                            source: teacher.id,
                            target: node.id,
                            type: 'teaching'
                        });
                    }
                });

                // Incarnation relationships
                node.incarnationOf.forEach(prevName => {
                    const prev = nodes.find(n => n.id === prevName.trim());
                    if (prev) {
                        links.push({
                            source: prev.id,
                            target: node.id,
                            type: 'incarnation'
                        });
                    }
                });

                // Family relationships
                node.familyFrom.forEach(familyName => {
                    const family = nodes.find(n => n.id === familyName.trim());
                    if (family) {
                        links.push({
                            source: family.id,
                            target: node.id,
                            type: 'family'
                        });
                    }
                });

                // Emanation relationships
                node.emanatedAs.forEach(emanationName => {
                    const emanation = nodes.find(n => n.id === emanationName.trim());
                    if (emanation) {
                        links.push({
                            source: node.id,
                            target: emanation.id,
                            type: 'emanation'
                        });
                    }
                });
            });

            // Debug: Check transmission types
            const transmissionTypes = [...new Set(nodes.map(n => n.transmission))];
            console.log('Transmission types found:', transmissionTypes);

            // Debug: Count by transmission
            const transmissionCounts = {};
            nodes.forEach(n => {
                transmissionCounts[n.transmission] = (transmissionCounts[n.transmission] || 0) + 1;
            });
            console.log('Transmission counts:', transmissionCounts);

            // Debug: Check first few Mind to Mind nodes
            const mindToMindNodes = nodes.filter(n => n.transmission === 'Mind to Mind');
            console.log(`Found ${mindToMindNodes.length} Mind to Mind nodes:`, mindToMindNodes.slice(0, 3));

            console.log(`Loaded ${nodes.length} nodes and ${links.length} links`);
        }

        // Create normalized time-based Y-scale for optimal vertical spacing
        function createNormalizedTimeScale(nodes) {
            // Sort nodes by time position
            const sortedNodes = [...nodes].sort((a, b) => a.position - b.position);

            if (sortedNodes.length === 0) return (pos) => margin.top;

            // Calculate time gaps between consecutive nodes
            const gaps = [];
            for (let i = 1; i < sortedNodes.length; i++) {
                const gap = sortedNodes[i].position - sortedNodes[i-1].position;
                gaps.push({
                    startTime: sortedNodes[i-1].position,
                    endTime: sortedNodes[i].position,
                    gap: gap,
                    startNode: sortedNodes[i-1],
                    endNode: sortedNodes[i]
                });
            }

            // Define minimum spacing between nodes (pixels)
            const minNodeSpacing = 15 * densitySensitivity;
            const maxGapSpacing = 40 * densitySensitivity;

            // Assign Y positions based on normalized spacing
            const yPositions = new Map();
            let currentY = margin.top;

            // Set first node position
            yPositions.set(sortedNodes[0].position, currentY);
            currentY += minNodeSpacing;

            // Calculate spacing for each gap
            gaps.forEach(gapInfo => {
                const { gap, endNode } = gapInfo;

                // Determine spacing based on time gap
                let spacing;
                if (gap <= 5) {
                    spacing = minNodeSpacing;
                } else if (gap <= 25) {
                    spacing = minNodeSpacing * 1.2;
                } else if (gap <= 50) {
                    spacing = minNodeSpacing * 1.5;
                } else if (gap <= 100) {
                    spacing = minNodeSpacing * 2;
                } else {
                    spacing = Math.min(maxGapSpacing, minNodeSpacing * 2.5);
                }

                yPositions.set(endNode.position, currentY);
                currentY += spacing;
            });

            // Constrain total height to reasonable viewport size
            const maxAllowedHeight = height * 3;
            if (currentY > maxAllowedHeight) {
                const scaleFactor = maxAllowedHeight / currentY;
                yPositions.forEach((y, position) => {
                    yPositions.set(position, margin.top + (y - margin.top) * scaleFactor);
                });
                currentY = maxAllowedHeight;
            }

            // Create interpolation function
            const yScale = (position) => {
                let beforeNode = null;
                let afterNode = null;

                for (let i = 0; i < sortedNodes.length; i++) {
                    if (sortedNodes[i].position <= position) {
                        beforeNode = sortedNodes[i];
                    }
                    if (sortedNodes[i].position >= position && !afterNode) {
                        afterNode = sortedNodes[i];
                        break;
                    }
                }

                if (!beforeNode) return yPositions.get(afterNode.position);
                if (!afterNode) return yPositions.get(beforeNode.position);
                if (beforeNode === afterNode) return yPositions.get(beforeNode.position);

                const beforeY = yPositions.get(beforeNode.position);
                const afterY = yPositions.get(afterNode.position);
                const timeDiff = afterNode.position - beforeNode.position;
                const progress = (position - beforeNode.position) / timeDiff;

                return beforeY + (afterY - beforeY) * progress;
            };

            // Store info for axis creation
            yScale.nodePositions = yPositions;
            yScale.sortedNodes = sortedNodes;
            yScale.totalHeight = currentY;

            return yScale;
        }

        function createNormalizedTimeAxis(container, yScale) {
            const timeAxis = container.append('g')
                .attr('class', 'time-axis')
                .style('display', layoutMode === 'linear' ? 'block' : 'none');

            const sortedNodes = yScale.sortedNodes;
            const nodePositions = yScale.nodePositions;

            // Add main axis line
            timeAxis.append('line')
                .attr('x1', margin.left - 20)
                .attr('x2', margin.left - 20)
                .attr('y1', margin.top)
                .attr('y2', yScale.totalHeight)
                .attr('stroke', '#444')
                .attr('stroke-width', 2);

            // Create time markers
            const timeMarkers = [];
            const timeExtent = d3.extent(sortedNodes, d => d.position);

            // Add century markers
            for (let year = Math.floor(timeExtent[0] / 100) * 100; year <= Math.ceil(timeExtent[1] / 100) * 100; year += 100) {
                if (year >= timeExtent[0] && year <= timeExtent[1]) {
                    timeMarkers.push({ year: year, type: 'century' });
                }
            }

            // Add 50-year markers
            for (let year = Math.floor(timeExtent[0] / 50) * 50; year <= Math.ceil(timeExtent[1] / 50) * 50; year += 50) {
                if (year >= timeExtent[0] && year <= timeExtent[1] && year % 100 !== 0) {
                    timeMarkers.push({ year: year, type: 'half-century' });
                }
            }

            // Add node markers
            sortedNodes.forEach((node, i) => {
                if (i % 5 === 0) {
                    timeMarkers.push({ year: node.position, type: 'node', node: node });
                }
            });

            timeMarkers.forEach(marker => {
                const y = yScale(marker.year);
                const g = timeAxis.append('g').attr('class', 'time-tick');

                if (marker.type === 'century') {
                    g.append('line')
                        .attr('x1', margin.left - 30)
                        .attr('x2', margin.left - 15)
                        .attr('y1', y)
                        .attr('y2', y)
                        .attr('stroke', '#888')
                        .attr('stroke-width', 2);

                    g.append('text')
                        .attr('x', margin.left - 35)
                        .attr('y', y + 4)
                        .attr('class', 'time-label')
                        .style('fill', '#aaa')
                        .text(marker.year > 0 ? `${marker.year} CE` : `${Math.abs(marker.year)} BCE`);

                } else if (marker.type === 'half-century') {
                    g.append('line')
                        .attr('x1', margin.left - 25)
                        .attr('x2', margin.left - 15)
                        .attr('y1', y)
                        .attr('y2', y)
                        .attr('stroke', '#555')
                        .attr('stroke-width', 1);

                } else if (marker.type === 'node') {
                    g.append('circle')
                        .attr('cx', margin.left - 20)
                        .attr('cy', y)
                        .attr('r', 2)
                        .attr('fill', '#4a90e2')
                        .attr('opacity', 0.6);
                }
            });
        }

        function createVisualization() {
            const mainGroup = svg.select('.main-group');

            // Create time axis for linear mode (conditional)
            if (layoutMode === 'linear') {
                const yScale = createNormalizedTimeScale(nodes);
                createNormalizedTimeAxis(mainGroup, yScale);
            }

            // Create empty selections that will be populated by update()
            linkElements = mainGroup.append('g')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .selectAll('line');

            nodeElements = mainGroup.append('g')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .selectAll('circle');

            // Create force simulation (empty initially)
            createTemporalSimulation();

            // Initial update
            updateTimeDisplay();
            updateVisualization();
        }

        function createTemporalSimulation() {
            if (layoutMode === 'circular') {
                // Circular mode: center-focused forces
                simulation = d3.forceSimulation()
                    .force('charge', d3.forceManyBody().strength(-100))
                    .force('link', d3.forceLink().id(d => d.id).distance(50).strength(0.3))
                    .force('x', d3.forceX(centerX).strength(0.1))
                    .force('y', d3.forceY(centerY).strength(0.1))
                    .force('collision', d3.forceCollide().radius(d => {
                        const connections = d.teachers.length + d.students.length;
                        return Math.max(6, Math.min(14, connections * 1.5 + 6));
                    }))
                    .on('tick', tick);
            } else {
                // Linear mode: time-based Y positioning with moderate horizontal spread
                const yScale = createNormalizedTimeScale(nodes);
                simulation = d3.forceSimulation()
                    .force('charge', d3.forceManyBody().strength(-120)) // Moderate repulsion
                    .force('link', d3.forceLink().id(d => d.id).distance(50).strength(0.3))
                    .force('x', d3.forceX(centerX).strength(0.05)) // Gentle X centering
                    .force('y', d3.forceY(d => yScale(d.position)).strength(0.9))
                    .force('collision', d3.forceCollide().radius(d => {
                        const connections = d.teachers.length + d.students.length;
                        return Math.max(7, Math.min(15, connections * 1.8 + 7)); // Moderate collision radius
                    }))
                    .on('tick', tick);
            }
        }

        function tick() {
            // Update link positions
            linkElements
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            // Update node positions
            nodeElements
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
        }

        function updateVisualization() {
            const maxPosition = Math.max(...nodes.map(n => n.position));
            const minPosition = Math.min(...nodes.map(n => n.position));
            const timeThreshold = minPosition + (currentTime / 100) * (maxPosition - minPosition);

            // Filter nodes that exist at current time and match filters
            const visibleNodes = nodes.filter(d => {
                const existsAtTime = d.position <= timeThreshold;
                const transmissionMatch = currentFilter === 'all' || d.transmission === currentFilter;
                const lineageMatch = currentLineageFilter === 'all' ||
                                   d.lineage === currentLineageFilter ||
                                   d.lineage === 'All lineages' ||
                                   d.lineage.includes(currentLineageFilter);


                return existsAtTime && transmissionMatch && lineageMatch;
            });

            // Filter links where both nodes are visible
            const visibleNodeIds = new Set(visibleNodes.map(d => d.id));
            const visibleLinks = links.filter(d =>
                visibleNodeIds.has(d.source.id || d.source) &&
                visibleNodeIds.has(d.target.id || d.target)
            );

            // Update the simulation - CRITICAL: preserve old node positions
            updateSimulation(visibleNodes, visibleLinks);
        }

        function updateSimulation(visibleNodes, visibleLinks) {
            // Make a shallow copy to protect against mutation, while
            // recycling old nodes to preserve position and velocity.
            const old = new Map(nodeElements.data().map(d => [d.id, d]));
            const updatedNodes = visibleNodes.map(d => {
                const oldNode = old.get(d.id);
                if (oldNode) {
                    // Preserve existing node with its position
                    return {...oldNode, ...d};
                } else {
                    // New node - set good initial position to prevent fly-in effect
                    const newNode = {...d};
                    if (layoutMode === 'circular') {
                        // For circular mode, start near center with small random offset
                        newNode.x = centerX + (Math.random() - 0.5) * 100;
                        newNode.y = centerY + (Math.random() - 0.5) * 100;
                    } else {
                        // For linear mode, start at appropriate Y position with wider X spread
                        const yScale = createNormalizedTimeScale(nodes);
                        newNode.x = centerX + (Math.random() - 0.5) * 200; // Much wider initial spread
                        newNode.y = yScale(d.position);
                    }
                    return newNode;
                }
            });
            const updatedLinks = visibleLinks.map(d => ({...d}));

            // Update nodes with enter/exit pattern
            nodeElements = nodeElements
                .data(updatedNodes, d => d.id)
                .join(enter => enter.append('circle')
                    .attr('r', d => {
                        // Make Samantabhadra/Samantabhadri larger (primordial source)
                        if (d.name.toLowerCase().includes('samantabhadra') ||
                            d.name.toLowerCase().includes('samantabhadri')) {
                            return 16; // Larger for the primordial Buddha
                        }
                        const connections = d.teachers.length + d.students.length;
                        return Math.max(4, Math.min(12, connections * 1.2 + 4));
                    })
                    .attr('class', d => `node ${d.transmission.toLowerCase().replace(/\s+/g, '-')}`)
                    .call(drag(simulation))
                    .on('mouseover', showTooltip)
                    .on('mouseout', hideTooltip)
                    .call(node => node.append('title').text(d => d.name))
                );

            // Update links with enter/exit pattern
            linkElements = linkElements
                .data(updatedLinks, d => [d.source.id || d.source, d.target.id || d.target])
                .join('line')
                .attr('class', d => `link ${d.type}`);

            // Update simulation forces
            simulation.nodes(updatedNodes);
            simulation.force('link').links(updatedLinks);
            simulation.alpha(1).restart();

            // Reapply traceback highlighting if active
            if (tracebackActive) {
                applyTracebackHighlighting();
            }
        }

        // Add drag functionality
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;

                // Track initial position for click vs drag detection
                dragStart = { x: event.x, y: event.y };
                isDragging = false;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;

                // Check if we've moved enough to consider this a drag
                const distance = Math.sqrt(
                    Math.pow(event.x - dragStart.x, 2) +
                    Math.pow(event.y - dragStart.y, 2)
                );
                if (distance > 5) {
                    isDragging = true;
                }
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;

                // If no significant dragging occurred, treat as a click and trigger traceback
                if (!isDragging) {
                    console.log('Node clicked (not dragged) - triggering traceback for:', d.name);
                    activateTraceback(d);
                }
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }

        function updateTimeDisplay() {
            const maxPosition = Math.max(...nodes.map(n => n.position));
            const minPosition = Math.min(...nodes.map(n => n.position));
            const currentYear = Math.round(minPosition + (currentTime / 100) * (maxPosition - minPosition));
            document.getElementById('timeDisplay').textContent = `Time Position: ${currentYear}`;
        }

        function showTooltip(event, d) {
            tooltip.transition().duration(200).style('opacity', .9);
            tooltip.html(`
                <strong>${d.name}</strong><br/>
                Transmission: ${d.transmission}<br/>
                Lineage: ${d.lineage}<br/>
                Time Position: ${d.position}<br/>
                Teachers: ${d.teachers.length}<br/>
                Students: ${d.students.length}
            `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 28) + 'px');
        }

        function hideTooltip() {
            tooltip.transition().duration(500).style('opacity', 0);
        }

        // Control functions
        function playTime() {
            if (!isPlaying) {
                isPlaying = true;
                playInterval = setInterval(() => {
                    currentTime += animationSpeed;
                    if (currentTime > 100) {
                        currentTime = 100;
                        pauseTime();
                    }
                    document.getElementById('timeSlider').value = currentTime;
                    updateTimeDisplay();
                    updateVisualization();
                }, 100);
            }
        }

        function pauseTime() {
            isPlaying = false;
            if (playInterval) {
                clearInterval(playInterval);
            }
        }

        function resetTime() {
            pauseTime();
            currentTime = 0;
            document.getElementById('timeSlider').value = currentTime;
            updateTimeDisplay();
            updateVisualization();
        }

        function filterTransmission(mode) {
            currentFilter = mode;

            // Update button states
            document.querySelectorAll('.controls .control-group:nth-child(5) button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            updateVisualization();
        }

        function filterLineage(lineage) {
            currentLineageFilter = lineage;

            // Update button states
            document.querySelectorAll('.controls .control-group:nth-child(6) button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            updateVisualization();
        }

        function setLayoutMode(mode) {
            if (layoutMode !== mode) {
                layoutMode = mode;

                // Update button states
                document.querySelectorAll('.controls .control-group:nth-child(7) button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(mode === 'linear' ? 'linear-btn' : 'circular-btn').classList.add('active');

                // Toggle time axis visibility
                const timeAxis = svg.select('.time-axis');
                if (timeAxis.node()) {
                    timeAxis.style('display', mode === 'linear' ? 'block' : 'none');
                }

                // Recreate simulation and axis if needed
                if (mode === 'linear' && !svg.select('.time-axis').node()) {
                    // Create time axis if switching to linear for the first time
                    const mainGroup = svg.select('.main-group');
                    const yScale = createNormalizedTimeScale(nodes);
                    createNormalizedTimeAxis(mainGroup, yScale);
                }

                // Stop current simulation and create new one
                if (simulation) {
                    simulation.stop();
                }
                createTemporalSimulation();

                // Re-run current visualization update
                updateVisualization();

                console.log(`Layout mode switched to: ${mode}`);
            }
        }

        // Traceback functionality
        function findPathToSource(targetNode) {
            const visited = new Set();
            const path = [];
            const pathLinks = [];

            function dfs(node) {
                if (visited.has(node.id)) return false;
                visited.add(node.id);
                path.push(node);

                // Check if we reached a primordial source
                if (node.name.toLowerCase().includes('samantabhadra') ||
                    node.name.toLowerCase().includes('samantabhadri') ||
                    node.teachers.length === 0) {
                    return true;
                }

                // Try each teacher (teaching relationships)
                for (const teacherName of node.teachers) {
                    const teacher = nodes.find(n => n.id === teacherName.trim());
                    if (teacher) {
                        // Find the teaching link between this node and teacher
                        const link = links.find(l =>
                            (l.source.id === teacher.id || l.source === teacher.id) &&
                            (l.target.id === node.id || l.target === node.id) &&
                            l.type === 'teaching'
                        );
                        if (link) pathLinks.push(link);

                        if (dfs(teacher)) {
                            return true;
                        }

                        // Remove link if path didn't work
                        if (link) pathLinks.pop();
                    }
                }

                // Try incarnation relationships (previous incarnations)
                if (node.incarnation_of && node.incarnation_of.length > 0) {
                    for (const incarnationName of node.incarnation_of) {
                        const incarnation = nodes.find(n => n.id === incarnationName.trim());
                        if (incarnation) {
                            // Find the incarnation link
                            const link = links.find(l =>
                                (l.source.id === incarnation.id || l.source === incarnation.id) &&
                                (l.target.id === node.id || l.target === node.id) &&
                                l.type === 'incarnation'
                            );
                            if (link) pathLinks.push(link);

                            if (dfs(incarnation)) {
                                return true;
                            }

                            // Remove link if path didn't work
                            if (link) pathLinks.pop();
                        }
                    }
                }

                // Try emanation relationships (what this master emanated from)
                if (node.emanated_from && node.emanated_from.length > 0) {
                    for (const emanationName of node.emanated_from) {
                        const emanation = nodes.find(n => n.id === emanationName.trim());
                        if (emanation) {
                            // Find the emanation link
                            const link = links.find(l =>
                                (l.source.id === emanation.id || l.source === emanation.id) &&
                                (l.target.id === node.id || l.target === node.id) &&
                                l.type === 'emanation'
                            );
                            if (link) pathLinks.push(link);

                            if (dfs(emanation)) {
                                return true;
                            }

                            // Remove link if path didn't work
                            if (link) pathLinks.pop();
                        }
                    }
                }

                path.pop();
                return false;
            }

            if (dfs(targetNode)) {
                return { nodes: [...path], links: [...pathLinks] };
            }
            return { nodes: [], links: [] };
        }

        function activateTraceback(clickedNode) {
            clearTraceback();
            tracebackActive = true;

            const path = findPathToSource(clickedNode);

            if (path.nodes.length === 0) {
                console.log(`No path found from ${clickedNode.name}`);
                return;
            }

            console.log(`Traceback from ${clickedNode.name} found ${path.nodes.length} nodes in path:`);
            path.nodes.forEach((node, i) => {
                console.log(`  ${i + 1}. ${node.name} (${node.transmission}) - Position: ${node.position}`);
            });

            // Animate the traceback flow step by step
            animateTracebackFlow(path);
        }

        function animateTracebackFlow(path) {
            const { nodes: pathNodes, links: pathLinks } = path;
            const animationDelay = 250; // milliseconds between each step (faster flow)

            // First dim all elements
            nodeElements.classed('dimmed', true);
            linkElements.classed('dimmed', true);

            // Animate each step in the path with flowing effect
            pathNodes.forEach((node, index) => {
                const timeoutId = setTimeout(() => {
                    // Add this node to traced set and highlight it
                    tracedNodes.add(node.id);
                    console.log(`Step ${index + 1}: Highlighting node "${node.name}" (${node.transmission}) at position ${node.position}`);

                    // Highlight the node with dramatic pulse effect
                    nodeElements
                        .filter(d => d.id === node.id)
                        .classed('dimmed', false)
                        .classed('traced', true)
                        .transition()
                        .duration(150)
                        .style('opacity', 1)
                        .attr('r', d => {
                            // Special handling for Samantabhadra/Samantabhadri
                            if (d.name.toLowerCase().includes('samantabhadra') ||
                                d.name.toLowerCase().includes('samantabhadri')) {
                                return 20; // Bigger pulse for primordial Buddha
                            }
                            const connections = d.teachers.length + d.students.length;
                            const baseRadius = Math.max(4, Math.min(12, connections * 1.2 + 4));
                            return baseRadius * 1.5; // Bigger pulse
                        })
                        .transition()
                        .duration(300)
                        .attr('r', d => {
                            // Return to large size for Samantabhadra/Samantabhadri
                            if (d.name.toLowerCase().includes('samantabhadra') ||
                                d.name.toLowerCase().includes('samantabhadri')) {
                                return 16;
                            }
                            const connections = d.teachers.length + d.students.length;
                            return Math.max(4, Math.min(12, connections * 1.2 + 4));
                        });

                    // If there's a link to the previous node, animate it with flowing effect
                    if (index > 0) {
                        const linkToHighlight = pathLinks[index - 1];
                        if (linkToHighlight) {
                            tracedLinks.add(linkToHighlight);

                            // Find link by matching source and target IDs
                            const linkElement = linkElements.filter(d => {
                                const sourceId = d.source.id || d.source;
                                const targetId = d.target.id || d.target;
                                const pathSourceId = linkToHighlight.source.id || linkToHighlight.source;
                                const pathTargetId = linkToHighlight.target.id || linkToHighlight.target;
                                return sourceId === pathSourceId && targetId === pathTargetId;
                            });

                            console.log('Found link element:', linkElement.size(), 'for source:', linkToHighlight.source.id, 'target:', linkToHighlight.target.id);

                            if (linkElement.size() > 0) {
                                console.log('Applying styles to link element');
                                linkElement
                                    .classed('dimmed', false)
                                    .classed('traced', true)
                                    .style('stroke', '#ffff00')
                                    .style('stroke-width', '5px')
                                    .style('opacity', '1');

                                // Add shadow effect after a brief delay
                                setTimeout(() => {
                                    linkElement.style('filter', 'drop-shadow(0 0 8px #ffff00)');
                                }, 50);
                            } else {
                                console.log('No link element found!');
                            }

                            // Add a flowing particle effect (only if link element was found)
                            if (linkElement.size() > 0) {
                                setTimeout(() => {
                                    createFlowingParticle(linkElement.node(), linkToHighlight);
                                }, 100);
                            }
                        }
                    }

                }, index * animationDelay);

                tracebackTimeouts.push(timeoutId);
            });
        }

        function createFlowingParticle(linkElement, linkData) {
            if (!linkElement || !linkData.source || !linkData.target) return;

            const sourceX = linkData.source.x || 0;
            const sourceY = linkData.source.y || 0;
            const targetX = linkData.target.x || 0;
            const targetY = linkData.target.y || 0;

            // Create a flowing particle (small circle) that moves along the link
            const particle = svg.select('.main-group')
                .append('circle')
                .attr('r', 3)
                .attr('fill', '#ffff00')
                .attr('opacity', 0.8)
                .attr('cx', sourceX)
                .attr('cy', sourceY)
                .style('filter', 'drop-shadow(0 0 6px #ffff00)')
                .style('pointer-events', 'none');

            // Animate particle along the link
            particle
                .transition()
                .duration(600)
                .ease(d3.easeQuadOut)
                .attr('cx', targetX)
                .attr('cy', targetY)
                .style('opacity', 0)
                .remove();
        }

        function clearTraceback() {
            tracebackActive = false;

            // Clear all pending timeouts to stop animation
            tracebackTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            tracebackTimeouts = [];

            // Stop all transitions
            nodeElements.interrupt();
            linkElements.interrupt();

            // Remove all particles
            svg.selectAll('circle[fill="#ffff00"]').remove();

            tracedNodes.clear();
            tracedLinks.clear();

            // Remove all traceback classes and reset styles
            nodeElements
                .classed('traced', false)
                .classed('dimmed', false)
                .style('opacity', null)
                .attr('r', d => {
                    // Keep Samantabhadra/Samantabhadri larger even when clearing traceback
                    if (d.name.toLowerCase().includes('samantabhadra') ||
                        d.name.toLowerCase().includes('samantabhadri')) {
                        return 16;
                    }
                    const connections = d.teachers.length + d.students.length;
                    return Math.max(4, Math.min(12, connections * 1.2 + 4));
                });

            linkElements
                .classed('traced', false)
                .classed('dimmed', false)
                .classed('flowing', false)
                .style('opacity', null)
                .style('stroke', null)
                .style('stroke-width', null)
                .style('filter', null)
                .style('stroke-dasharray', null)
                .style('animation', null);

            console.log('Traceback cleared');
        }

        function applyTracebackHighlighting() {
            if (!tracebackActive) return;

            // Highlight traced nodes, dim others
            nodeElements
                .classed('traced', d => tracedNodes.has(d.id))
                .classed('dimmed', d => !tracedNodes.has(d.id));

            // Highlight traced links using ID matching, dim others
            linkElements
                .each(function(d) {
                    const isTraced = [...tracedLinks].some(tracedLink => {
                        const sourceId = d.source.id || d.source;
                        const targetId = d.target.id || d.target;
                        const tracedSourceId = tracedLink.source.id || tracedLink.source;
                        const tracedTargetId = tracedLink.target.id || tracedLink.target;
                        return sourceId === tracedSourceId && targetId === tracedTargetId;
                    });

                    if (isTraced) {
                        d3.select(this)
                            .classed('dimmed', false)
                            .classed('traced', true)
                            .style('stroke', '#ffff00')
                            .style('stroke-width', '4px')
                            .style('opacity', '1');
                    } else {
                        d3.select(this)
                            .classed('dimmed', true)
                            .classed('traced', false);
                    }
                });
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);

        // Add body click listener to clear traceback
        document.addEventListener('click', function(event) {
            // Only clear if clicking outside of nodes and controls
            if (!event.target.closest('.node') && !event.target.closest('.controls') && !event.target.closest('circle')) {
                clearTraceback();
            }
        });
    </script>
</body>
</html>